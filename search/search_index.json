{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A flexible, modular version monitoring tool that tracks changes across multiple sources including PyPI, Conda channels (conda-forge, bioconda, custom), and arbitrary URLs.</p> <p> </p> <p>Table of Contents</p> <ul> <li>Features</li> <li>Installation</li> <li>Quick Start</li> <li>Supported Providers</li> <li>PyPI</li> <li>Conda</li> <li>Bioconda</li> <li>Conda-forge</li> <li>Version Constraints</li> <li>Usage Examples</li> <li>License</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd0d Multi-source monitoring - Track versions from PyPI, Conda, Bioconda, and arbitrary URLs</li> <li>\ud83d\udccf Version constraints - Monitor only versions matching specific criteria (e.g., \"&gt;=1.21,&lt;2.0\")</li> <li>\ud83c\udfaf Flexible parsing - Built-in parsers for common formats (ETag, regex, JSON)</li> <li>\ud83d\udd27 Custom parsers - Write your own parsers for specialized sources</li> <li>\ud83d\udcbe Persistent storage - JSON-based database to track version changes</li> <li>\ud83d\udce2 Change notifications - Execute custom callbacks when versions change</li> <li>\ud83c\udf10 HTTP resilience - Built-in retries and error handling</li> <li>\ud83c\udfd7\ufe0f Modular architecture - Clean separation of concerns for easy extension</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install glasscandle\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from glasscandle import Watcher\n\n# Create a watcher instance\nwatch = Watcher(\"versions.json\")\n\n# Optional: Add change notification callback\ndef on_version_change(key: str, old: str, new: str):\n    print(f\"\ud83d\udce6 {key} updated: {old} \u2192 {new}\")\n\n# Monitor PyPI packages\nwatch.pypi(\"requests\", on_change=on_version_change)\nwatch.pypi(\"numpy\")\n\n# Monitor Conda packages from any channel\nwatch.conda(\"pytorch\", channels=[\"pytorch\", \"conda-forge\"])\nwatch.conda(\"tensorflow\")  # Uses default channels\n\n# Monitor Bioconda packages\nwatch.bioconda(\"samtools\", on_change=on_version_change)\nwatch.bioconda(\"bwa\")\n\n# Monitor with version constraints\nwatch.pypi(\"django\", version=\"&gt;=4.0,&lt;5.0\", on_change=on_version_change)\nwatch.conda(\"numpy\", version=\"&gt;=1.21\", channels=[\"conda-forge\"])\nwatch.bioconda(\"blast\", version=\"~=2.12.0\")\n\n# Monitor a URL with ETag parsing (default)\nwatch.url(\"https://example.com/releases/latest\")\n\n# Monitor a URL with regex parsing\nwatch.url_regex(\n    \"https://example.com/version\", \n    r\"version:\\s*(\\d+\\.\\d+\\.\\d+)\",\n    on_change=on_version_change\n)\n\n# Run checks once\nwatch.run()\n\n# Or run continuously (every 60 seconds)\nwatch.start(interval=60)\n</code></pre>"},{"location":"#supported-providers","title":"Supported Providers","text":""},{"location":"#pypi","title":"PyPI","text":"<p>Monitor Python packages from the Python Package Index: <pre><code>watch.pypi(\"package-name\")\n\n# With version constraints\nwatch.pypi(\"django\", version=\"&gt;=4.0,&lt;5.0\")\nwatch.pypi(\"requests\", version=\"~=2.28.0\")  # Compatible release\n</code></pre></p>"},{"location":"#conda","title":"Conda","text":"<p>Monitor packages from Conda channels with full flexibility: <pre><code># Monitor from default channels (conda-forge, bioconda)\nwatch.conda(\"numpy\")\n\n# Monitor from specific channels\nwatch.conda(\"pytorch\", channels=[\"pytorch\", \"conda-forge\"])\nwatch.conda(\"tensorflow-gpu\", channels=[\"conda-forge\"])\n\n# With version constraints\nwatch.conda(\"numpy\", version=\"&gt;=1.21,&lt;2.0\", channels=[\"conda-forge\"])\nwatch.conda(\"scipy\", version=\"~=1.9.0\")  # Compatible release\n</code></pre></p>"},{"location":"#bioconda","title":"Bioconda","text":"<p>Monitor bioinformatics packages from Bioconda: <pre><code>watch.bioconda(\"package-name\")\n\n# With version constraints\nwatch.bioconda(\"samtools\", version=\"&gt;=1.15\")\nwatch.bioconda(\"blast\", version=\"~=2.12.0\")\n</code></pre></p>"},{"location":"#conda-forge","title":"Conda-forge","text":"<p>Monitor packages specifically from the conda-forge channel: <pre><code># Monitor any version from conda-forge\nwatch.condaforge(\"numpy\")\n\n# With version constraints\nwatch.condaforge(\"scipy\", version=\"&gt;=1.7,&lt;2.0\")\nwatch.condaforge(\"matplotlib\", version=\"~=3.5.0\")\n</code></pre></p>"},{"location":"#version-constraints","title":"Version Constraints","text":"<p>All package providers support version constraints using standard Python packaging syntax:</p> <pre><code># Greater than or equal to\nwatch.pypi(\"django\", version=\"&gt;=4.0\")\n\n# Range constraints\nwatch.conda(\"numpy\", version=\"&gt;=1.21,&lt;2.0\")\n\n# Compatible release (equivalent to &gt;=1.21.0,&lt;1.22.0)\nwatch.bioconda(\"blast\", version=\"~=1.21.0\")\n\n# Exact version\nwatch.pypi(\"requests\", version=\"==2.28.1\")\n\n# Not equal to\nwatch.conda(\"scipy\", version=\"&gt;=1.9,!=1.9.2\")\n\n# Complex constraints\nwatch.pypi(\"flask\", version=\"&gt;2.0,!=2.1.0,&lt;3.0\")\n</code></pre>"},{"location":"#json-apis","title":"JSON APIs","text":"<p>Monitor JSON endpoints using JSONPath expressions: <pre><code># GitHub releases\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \"$.tag_name\")\n\n# npm packages\nwatch.json(\"https://registry.npmjs.org/package/latest\", \"$.version\")\n\n# Complex nested paths\nwatch.json(\"https://api.example.com/data\", \"$.results[0].version\")\n</code></pre></p>"},{"location":"#url-with-built-in-parsers","title":"URL with Built-in Parsers","text":"<p>Monitor arbitrary URLs using built-in parsers: <pre><code># ETag parser (default)\nwatch.url(\"https://example.com/file\")\n\n# Last-Modified parser\nfrom glasscandle import last_modified\nwatch.url(\"https://example.com/file\", parser=last_modified)\n\n# SHA256 hash parser\nfrom glasscandle import sha256_of_body\nwatch.url(\"https://example.com/file\", parser=sha256_of_body)\n\n# Regex parser\nwatch.url_regex(\"https://example.com/version\", r\"v(\\d+\\.\\d+\\.\\d+)\")\n\n# JSON parser with JSONPath\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \"$.tag_name\")\n</code></pre></p>"},{"location":"#custom-url-parsers","title":"Custom URL Parsers","text":"<p>Write custom parsers for specialized sources: <pre><code>from glasscandle import Response\n\n@watch.response(\"https://api.github.com/repos/user/repo/releases/latest\")\ndef github_latest_release(res: Response):\n    \"\"\"Extract the latest release tag from GitHub API.\"\"\"\n    data = res.json()\n    return data[\"tag_name\"]\n</code></pre></p>"},{"location":"#change-notifications","title":"Change Notifications","text":"<p>Execute custom functions when versions change: <pre><code>def notify_change(key: str, old_version: str, new_version: str):\n    print(f\"\ud83d\udce6 {key} updated: {old_version} \u2192 {new_version}\")\n    # Send email, webhook, Slack notification, etc.\n\n# Add callbacks to any provider\nwatch.pypi(\"requests\", on_change=notify_change)\nwatch.conda(\"numpy\", version=\"&gt;=1.21\", on_change=notify_change)\nwatch.bioconda(\"samtools\", on_change=notify_change)\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \"$.tag_name\", on_change=notify_change)\nwatch.url(\"https://example.com/version\", on_change=notify_change)\n\n# Custom URLs with callbacks\n@watch.response(\"https://api.github.com/repos/user/repo/releases\", \n                on_change=notify_change)\ndef custom_parser(res: Response):\n    return res.json()[0][\"tag_name\"]\n</code></pre></p>"},{"location":"#built-in-notification-helpers","title":"Built-in Notification Helpers","text":"<p>Use pre-built notification functions for common services: <pre><code>from glasscandle.notifications import slack_notifier, multi_notifier\n\n# Slack notifications (uses SLACK_WEBHOOK_URL env var)\nslack_notify = slack_notifier()\nwatch.pypi(\"django\", version=\"&gt;=4.0\", on_change=slack_notify)\n\n# Email notifications (uses EMAIL_* env vars)  \nemail_notify = email_notifier()\nwatch.conda(\"numpy\", version=\"&gt;=1.21\", on_change=email_notify)\n\n# Multiple notification methods\nmulti_notify = multi_notifier(slack_notify, email_notify)\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \n           \"$.tag_name\", on_change=multi_notify)\n\n# Direct external function calls\nfrom glasscandle.external.slack import send_slack_msg\nimport os\n\ndef custom_notifier(key: str, old: str, new: str):\n    webhook_url = os.getenv(\"SLACK_WEBHOOK_URL\")\n    send_slack_msg(f\"Version Update: {key}\", f\"Updated from {old} \u2192 {new}\", webhook_url=webhook_url)\n\nwatch.pypi(\"requests\", on_change=custom_notifier)\n</code></pre></p>"},{"location":"#github-actions-integration","title":"GitHub Actions Integration","text":"<p>Watcher is designed to work seamlessly with GitHub Actions for automated monitoring:</p>"},{"location":"#1-environment-variables","title":"1. Environment Variables","text":"<p>Set these as GitHub repository secrets: - <code>SLACK_WEBHOOK_URL</code> - Required for Slack notifications - <code>EMAIL_TO</code> - Optional email recipient - <code>EMAIL_SMTP_SERVER</code> - Optional SMTP server - <code>EMAIL_USERNAME</code> - Optional SMTP username - <code>EMAIL_PASSWORD</code> - Optional SMTP password</p>"},{"location":"#2-github-actions-workflow","title":"2. GitHub Actions Workflow","text":"<p>Create <code>.github/workflows/version-watcher.yml</code>: <pre><code>name: Version Watcher\non:\n  schedule:\n    - cron: '0 */6 * * *'  # Every 6 hours\n  workflow_dispatch:\n\njobs:\n  watch-versions:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    - uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n    - run: pip install watcher\n    - run: python watch_script.py\n      env:\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n    - run: |\n        git config --local user.email \"action@github.com\"\n        git config --local user.name \"GitHub Action\"\n        git add .\n        git diff --staged --quiet || git commit -m \"Update versions [skip ci]\"\n        git push\n</code></pre></p>"},{"location":"#3-watch-script","title":"3. Watch Script","text":"<p>Create a <code>watch_script.py</code> that uses environment variables: <pre><code>import os\nfrom glasscandle import Watcher\nfrom glasscandle.notifications import slack_notifier\n\nwatch = Watcher(\"versions.json\")\nnotify = slack_notifier()  # Uses SLACK_WEBHOOK_URL env var\n\nwatch.pypi(\"requests\", on_change=notify)\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \n           \"$.tag_name\", on_change=notify)\n\nwatch.run()\n</code></pre></p>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#basic-version-monitoring","title":"Basic Version Monitoring","text":"<pre><code>from glasscandle import Watcher\n\nwatch = Watcher(\"my-versions.json\")\n\n# Add packages to monitor\nwatch.pypi(\"django\")\nwatch.pypi(\"flask\", version=\"&gt;=2.0\")\nwatch.conda(\"numpy\", channels=[\"conda-forge\"])\nwatch.bioconda(\"blast\", version=\"~=2.12.0\")\n\n# Check once\nwatch.run()\n</code></pre>"},{"location":"#version-constraint-examples","title":"Version Constraint Examples","text":"<pre><code>from glasscandle import Watcher\n\nwatch = Watcher(\"versions.json\")\n\n# Monitor only major version 4.x of Django\nwatch.pypi(\"django\", version=\"&gt;=4.0,&lt;5.0\")\n\n# Monitor compatible releases (patch-level updates)\nwatch.conda(\"numpy\", version=\"~=1.21.0\")\n\n# Complex constraints with exclusions\nwatch.pypi(\"requests\", version=\"&gt;=2.28,!=2.28.2,&lt;3.0\")\n\n# Monitor latest of any version (default behavior)\nwatch.bioconda(\"samtools\")\n\nwatch.run()\n</code></pre>"},{"location":"#advanced-url-monitoring","title":"Advanced URL Monitoring","text":"<pre><code>from glasscandle import Watcher, regex, etag\n\nwatch = Watcher(\"versions.json\")\n\n# Monitor with different parsers\nwatch.url(\"https://releases.example.com/latest\", parser=etag)\nwatch.url_regex(\"https://version.example.com\", r\"Version (\\d+\\.\\d+)\")\nwatch.json(\"https://api.example.com/version\", \"$.latest\")\n\n# Custom domain restrictions\nwatch = Watcher(\n    \"versions.json\", \n    allowed_custom_domains=(\"trusted.com\", \"example.org\")\n)\n</code></pre>"},{"location":"#continuous-monitoring","title":"Continuous Monitoring","text":"<pre><code>from glasscandle import Watcher\n\nwatch = Watcher(\"versions.json\")\n\n# Add your packages with constraints\nwatch.pypi(\"requests\", version=\"&gt;=2.28,&lt;3.0\")\nwatch.conda(\"pytorch\", channels=[\"pytorch\"], version=\"&gt;=1.12\")\nwatch.bioconda(\"samtools\", version=\"&gt;=1.15\")\nwatch.json(\"https://api.github.com/repos/user/repo/releases/latest\", \"$.tag_name\")\n\n# Start monitoring (checks every 5 minutes)\nwatch.start(interval=300)\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>watcher</code> is distributed under the terms of the MIT license.</p>"},{"location":"GITHUB_ACTIONS/","title":"GitHub Actions Setup","text":"<p>This guide shows you how to set up GitHub Actions to automatically run Watcher on a schedule or when code changes are pushed to your repository.</p>"},{"location":"GITHUB_ACTIONS/#overview","title":"Overview","text":"<p>GitHub Actions allows you to run Watcher automatically in the cloud, making it perfect for: - Monitoring packages, APIs, or websites on a schedule - Getting notifications when changes are detected - Maintaining a persistent database of version history</p>"},{"location":"GITHUB_ACTIONS/#basic-setup","title":"Basic Setup","text":""},{"location":"GITHUB_ACTIONS/#1-create-the-workflow-file","title":"1. Create the Workflow File","text":"<p>Create a file at <code>.github/workflows/watcher.yml</code> in your repository:</p> <pre><code>name: GlassCandle\non:\n  # push:\n  #   branches: \n  #     - master\n  #     - main\n  schedule:\n      - cron: '0 0 * * *' # Run daily at midnight\n  workflow_dispatch: # Allow manual triggering\n\n\njobs:\n  glasscandle:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - name: Install dependencies\n        run: pip install glasscandle\n\n      - name: Run GlassCandle\n        env:\n          # Slack webhook URL stored as GitHub secret\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n          # Email notifications (stored as secrets)\n          EMAIL_TO: ${{ secrets.EMAIL_TO }}\n          EMAIL_SMTP_SERVER: ${{ secrets.EMAIL_SMTP_SERVER }}\n          EMAIL_USERNAME: ${{ secrets.EMAIL_USERNAME }}\n          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}\n          # Mastodon (stored as secrets)\n          MASTODON_ACCESS_TOKEN: ${{ secrets.MASTODON_ACCESS_TOKEN }}\n          MASTODON_API_BASE_URL: ${{ secrets.MASTODON_API_BASE_URL }}\n          # Bluesky (stored as secrets)\n          BSKY_USERNAME: ${{ secrets.BSKY_USERNAME }}\n          BSKY_PASSWORD: ${{ secrets.BSKY_PASSWORD }}\n\n        run: python examples/watch.py # Example script to run GlassCandle\n\n      - name: Commit and push version database changes\n        run: |\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GlassCandle\"\n          git add .\n          git diff --staged --quiet || git commit -m \"Update version database [skip ci]\"\n          git push\n</code></pre>"},{"location":"GITHUB_ACTIONS/#2-create-your-watcher-script","title":"2. Create Your Watcher Script","text":"<p>Create a Python script (e.g., <code>watcher_script.py</code>) in your repository:</p> <pre><code>from glasscandle import Watcher\n\n# Initialize watcher with a database file\nwatcher = Watcher(db_path=\"versions.json\")\n\n# Add your watchers\nwatcher.pypi(\"requests\", on_change=lambda k, o, n: print(f\"requests updated: {o} -&gt; {n}\"))\nwatcher.url(\"https://api.github.com/repos/microsoft/vscode/releases/latest\", \n           parser=\"$.tag_name\", \n           on_change=lambda k, o, n: print(f\"VS Code updated: {o} -&gt; {n}\"))\n\n# Run the watcher\nwatcher.run()\n</code></pre>"},{"location":"GITHUB_ACTIONS/#adding-notifications","title":"Adding Notifications","text":"<p>To get notified when changes are detected, you'll need to set up notification secrets and environment variables.</p>"},{"location":"GITHUB_ACTIONS/#setting-up-github-secrets","title":"Setting Up GitHub Secrets","text":"<ol> <li>Go to your repository on GitHub</li> <li>Click Settings \u2192 Secrets and variables \u2192 Actions</li> <li>Click New repository secret</li> <li>Add the secrets you need for your notification methods</li> </ol>"},{"location":"GITHUB_ACTIONS/#slack-notifications","title":"Slack Notifications","text":"<p>Add this secret: - <code>SLACK_WEBHOOK_URL</code>: Your Slack webhook URL</p> <p>Update your workflow to include the environment variable:</p> <pre><code>- name: Run watcher with notifications\n  env:\n    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n  run: python watcher_script.py\n</code></pre> <p>Update your watcher script:</p> <pre><code>from glasscandle import Watcher\nfrom glasscandle.notifications import slack_notifier\nimport os\n\n# Create notification function\nslack_notify = slack_notifier(\n    webhook_url=os.getenv('SLACK_WEBHOOK_URL'),\n    channel=\"#updates\"\n)\n\nwatcher = Watcher(db_path=\"versions.json\")\nwatcher.pypi(\"requests\", on_change=slack_notify)\nwatcher.run()\n</code></pre>"},{"location":"GITHUB_ACTIONS/#email-notifications","title":"Email Notifications","text":"<p>Add these secrets: - <code>EMAIL_TO</code>: Recipient email address - <code>EMAIL_SMTP_SERVER</code>: SMTP server (e.g., smtp.gmail.com) - <code>EMAIL_USERNAME</code>: Your email username - <code>EMAIL_PASSWORD</code>: Your email password or app password</p> <p>Update your workflow:</p> <pre><code>- name: Run watcher with email notifications\n  env:\n    EMAIL_TO: ${{ secrets.EMAIL_TO }}\n    EMAIL_SMTP_SERVER: ${{ secrets.EMAIL_SMTP_SERVER }}\n    EMAIL_USERNAME: ${{ secrets.EMAIL_USERNAME }}\n    EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}\n  run: python watcher_script.py\n</code></pre> <p>Update your watcher script:</p> <pre><code>from glasscandle import Watcher\nfrom glasscandle.notifications import email_notifier\nimport os\n\nemail_notify = email_notifier(\n    to_email=os.getenv('EMAIL_TO'),\n    smtp_server=os.getenv('EMAIL_SMTP_SERVER'),\n    username=os.getenv('EMAIL_USERNAME'),\n    password=os.getenv('EMAIL_PASSWORD')\n)\n\nwatcher = Watcher(db_path=\"versions.json\")\nwatcher.pypi(\"requests\", on_change=email_notify)\nwatcher.run()\n</code></pre>"},{"location":"GITHUB_ACTIONS/#mastodon-notifications","title":"Mastodon Notifications","text":"<p>Add these secrets: - <code>MASTODON_ACCESS_TOKEN</code>: Your Mastodon access token - <code>MASTODON_API_BASE_URL</code>: Your Mastodon instance URL (e.g., https://mastodon.social)</p> <pre><code>from glasscandle.notifications import mastodon_notifier\nimport os\n\nmastodon_notify = mastodon_notifier(\n    access_token=os.getenv('MASTODON_ACCESS_TOKEN'),\n    api_base_url=os.getenv('MASTODON_API_BASE_URL')\n)\n</code></pre>"},{"location":"GITHUB_ACTIONS/#bluesky-notifications","title":"BlueSky Notifications","text":"<p>Add these secrets: - <code>BSKY_USERNAME</code>: Your BlueSky username - <code>BSKY_PASSWORD</code>: Your BlueSky password</p> <pre><code>from glasscandle.notifications import bsky_notifier\nimport os\n\nbsky_notify = bsky_notifier(\n    username=os.getenv('BSKY_USERNAME'),\n    password=os.getenv('BSKY_PASSWORD')\n)\n</code></pre>"},{"location":"GITHUB_ACTIONS/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that combines multiple notification methods:</p> <p>.github/workflows/watcher.yml: <pre><code>name: Package Watcher\non:\n  schedule:\n    - cron: '0 */6 * * *' # Run every 6 hours\n  workflow_dispatch: # Allow manual triggering\n\njobs:\n  watch:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - run: pip install glasscandle\n\n      - name: Run watcher\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n          EMAIL_TO: ${{ secrets.EMAIL_TO }}\n          EMAIL_SMTP_SERVER: ${{ secrets.EMAIL_SMTP_SERVER }}\n          EMAIL_USERNAME: ${{ secrets.EMAIL_USERNAME }}\n          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}\n        run: python watch_packages.py\n\n      - name: Commit database changes\n        run: |\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GitHub Action\"\n          git add versions.json || true\n          git diff --staged --quiet || git commit -m \"Update package versions [skip ci]\"\n          git push || true\n</code></pre></p> <p>watch_packages.py: <pre><code>from glasscandle import Watcher\nfrom glasscandle.notifications import slack_notifier, email_notifier, multi_notifier\nimport os\n\n# Set up notifications\nnotifications = []\n\nif os.getenv('SLACK_WEBHOOK_URL'):\n    slack_notify = slack_notifier(\n        webhook_url=os.getenv('SLACK_WEBHOOK_URL'),\n        channel=\"#package-updates\"\n    )\n    notifications.append(slack_notify)\n\nif os.getenv('EMAIL_TO'):\n    email_notify = email_notifier(\n        to_email=os.getenv('EMAIL_TO'),\n        smtp_server=os.getenv('EMAIL_SMTP_SERVER'),\n        username=os.getenv('EMAIL_USERNAME'),\n        password=os.getenv('EMAIL_PASSWORD'),\n        subject=\"Package Update Alert\"\n    )\n    notifications.append(email_notify)\n\n# Combine all notification methods\nnotify = multi_notifier(*notifications) if notifications else None\n\n# Set up watcher\nwatcher = Watcher(db_path=\"versions.json\")\n\n# Watch various packages\npackages_to_watch = [\n    \"requests\",\n    \"numpy\", \n    \"pandas\",\n    \"django\",\n    \"flask\"\n]\n\nfor package in packages_to_watch:\n    watcher.pypi(package, on_change=notify)\n\n# Watch GitHub releases\nwatcher.url(\"https://api.github.com/repos/microsoft/vscode/releases/latest\",\n           parser=\"$.tag_name\",\n           key=\"vscode\",\n           on_change=notify)\n\n# Run the watcher\nprint(\"Starting package watcher...\")\nwatcher.run()\nprint(\"Watcher completed successfully!\")\n</code></pre></p>"},{"location":"GITHUB_ACTIONS/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"GITHUB_ACTIONS/#custom-schedules","title":"Custom Schedules","text":"<p>You can customize when your watcher runs using cron syntax:</p> <pre><code>schedule:\n  - cron: '0 9 * * 1-5'  # Weekdays at 9 AM UTC\n  - cron: '0 */4 * * *'  # Every 4 hours\n  - cron: '0 0 1 * *'    # First day of every month\n</code></pre>"},{"location":"GITHUB_ACTIONS/#multiple-environments","title":"Multiple Environments","text":"<p>You can set up different workflows for different environments:</p> <pre><code>strategy:\n  matrix:\n    environment: [production, staging]\n\nsteps:\n  - name: Run watcher\n    env:\n      ENVIRONMENT: ${{ matrix.environment }}\n    run: python watcher_${{ matrix.environment }}.py\n</code></pre>"},{"location":"GITHUB_ACTIONS/#error-handling","title":"Error Handling","text":"<p>Add error handling to your workflow:</p> <pre><code>- name: Run watcher\n  continue-on-error: true\n  run: python watcher_script.py\n\n- name: Notify on failure\n  if: failure()\n  run: |\n    echo \"Watcher failed, sending alert...\"\n    # Add failure notification logic here\n</code></pre>"},{"location":"GITHUB_ACTIONS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"GITHUB_ACTIONS/#common-issues","title":"Common Issues","text":"<ol> <li>Permission denied when pushing: Make sure your repository has Actions permission to write to the repository</li> <li>Secrets not accessible: Verify secrets are set correctly in repository settings</li> <li>Python package conflicts: Pin specific versions in requirements.txt</li> <li>Rate limiting: Add delays between requests or reduce frequency</li> </ol>"},{"location":"GITHUB_ACTIONS/#debugging","title":"Debugging","text":"<p>Add debug output to your watcher script:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Your watcher code here\n</code></pre> <p>Enable step debugging in your workflow:</p> <pre><code>- name: Debug environment\n  run: |\n    echo \"Python version: $(python --version)\"\n    echo \"Working directory: $(pwd)\"\n    echo \"Files: $(ls -la)\"\n    env\n</code></pre>"},{"location":"GITHUB_ACTIONS/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Use secrets: Never hardcode sensitive information like API keys or passwords</li> <li>Limit permissions: Use the principle of least privilege for your workflows</li> <li>Review dependencies: Regularly update and audit your Python dependencies</li> <li>Monitor logs: Regularly check your Action logs for any suspicious activity</li> </ol> <p>This setup will automatically monitor your specified packages and URLs, sending notifications when changes are detected, all running in GitHub's cloud infrastructure.</p>"},{"location":"NOTIFICATIONS/","title":"Notification Methods","text":"<p>This document describes the various notification methods available in the watcher package for alerting about version changes.</p>"},{"location":"NOTIFICATIONS/#quick-start","title":"Quick Start","text":"<p>The easiest way to set up notifications is using the built-in notification helpers:</p> <pre><code>from glasscandle import Watcher\nfrom glasscandle.notifications import slack_notifier, multi_notifier\n\n# Set up notifications using environment variables\nslack_notify = slack_notifier()  # Uses SLACK_WEBHOOK_URL env var\n\nwatch = Watcher(\"my_config.json\")\nwatch.pypi(\"requests\", on_change=slack_notify)\nwatch.run()\n</code></pre>"},{"location":"NOTIFICATIONS/#available-notification-methods","title":"Available Notification Methods","text":""},{"location":"NOTIFICATIONS/#1-slack-notifications","title":"1. Slack Notifications","text":"<p>Send notifications to Slack via webhooks.</p> <p>Environment Variables: - <code>SLACK_WEBHOOK_URL</code> - Your Slack webhook URL</p> <p>Usage: <pre><code>from glasscandle.notifications import slack_notifier\n\n# Using environment variable\nslack_notify = slack_notifier()\n\n# Or specify webhook URL directly\nslack_notify = slack_notifier(webhook_url=\"https://hooks.slack.com/...\")\n\n# Use with watcher\nwatch.pypi(\"django\", on_change=slack_notify)\n</code></pre></p>"},{"location":"NOTIFICATIONS/#2-email-notifications","title":"2. Email Notifications","text":"<p>Send notifications via SMTP email.</p> <p>Environment Variables: - <code>EMAIL_TO</code> - Recipient email address - <code>EMAIL_FROM</code> - Sender email address (optional, defaults to username) - <code>EMAIL_SMTP_SERVER</code> - SMTP server hostname - <code>EMAIL_SMTP_PORT</code> - SMTP server port (default: 587) - <code>EMAIL_USERNAME</code> - SMTP username - <code>EMAIL_PASSWORD</code> - SMTP password</p> <p>Usage: <pre><code>from glasscandle.notifications import email_notifier\n\n# Using environment variables\nemail_notify = email_notifier()\n\n# Or specify config directly\nemail_notify = email_notifier(smtp_config={\n    \"to\": \"admin@example.com\",\n    \"smtp_server\": \"smtp.gmail.com\",\n    \"smtp_port\": 587,\n    \"username\": \"your_email@gmail.com\",\n    \"password\": \"your_app_password\"\n})\n\nwatch.pypi(\"fastapi\", on_change=email_notify)\n</code></pre></p>"},{"location":"NOTIFICATIONS/#3-mastodon-notifications","title":"3. Mastodon Notifications","text":"<p>Post notifications to Mastodon instances.</p> <p>Environment Variables: - <code>MASTODON_ACCESS_TOKEN</code> - Your Mastodon access token - <code>MASTODON_API_BASE_URL</code> - Your Mastodon instance URL</p> <p>Installation: <pre><code>pip install Mastodon.py\n</code></pre></p> <p>Usage: <pre><code>from glasscandle.notifications import mastodon_notifier\n\n# Using environment variables\nmastodon_notify = mastodon_notifier()\n\n# Or specify credentials directly\nmastodon_notify = mastodon_notifier(\n    access_token=\"your_token\",\n    api_base_url=\"https://mastodon.social\"\n)\n\nwatch.pypi(\"pandas\", on_change=mastodon_notify)\n</code></pre></p>"},{"location":"NOTIFICATIONS/#4-bluesky-notifications","title":"4. Bluesky Notifications","text":"<p>Post notifications to Bluesky via AT Protocol.</p> <p>Environment Variables: - <code>BSKY_USERNAME</code> - Your Bluesky username/handle - <code>BSKY_PASSWORD</code> - Your Bluesky password or app password</p> <p>Usage: <pre><code>from glasscandle.notifications import bsky_notifier\n\n# Using environment variables\nbsky_notify = bsky_notifier()\n\n# Or specify credentials directly\nbsky_notify = bsky_notifier(\n    username=\"your_handle.bsky.social\",\n    password=\"your_password\"\n)\n\nwatch.pypi(\"numpy\", on_change=bsky_notify)\n</code></pre></p>"},{"location":"NOTIFICATIONS/#combining-multiple-notifications","title":"Combining Multiple Notifications","text":"<p>Use <code>multi_notifier</code> to send notifications through multiple channels:</p> <pre><code>from glasscandle.notifications import (\n    slack_notifier, email_notifier, mastodon_notifier, \n    bsky_notifier, multi_notifier\n)\n\n# Set up individual notifiers\nslack_notify = slack_notifier()\nemail_notify = email_notifier()\nmastodon_notify = mastodon_notifier()\n\n# Combine them\ncombined_notify = multi_notifier(\n    slack_notify,\n    email_notify,\n    mastodon_notify\n)\n\nwatch.pypi(\"requests\", on_change=combined_notify)\n</code></pre>"},{"location":"NOTIFICATIONS/#custom-notifications","title":"Custom Notifications","text":"<p>You can create custom notification functions:</p> <pre><code>def custom_notify(key: str, old_version: str, new_version: str):\n    \"\"\"Custom notification logic.\"\"\"\n    print(f\"\ud83d\udd04 {key}: {old_version} \u2192 {new_version}\")\n\n    # Add your custom logic here\n    # - Send to Discord\n    # - Update a dashboard\n    # - Write to a log file\n    # - etc.\n\nwatch.pypi(\"django\", on_change=custom_notify)\n</code></pre>"},{"location":"NOTIFICATIONS/#error-handling","title":"Error Handling","text":"<p>All notification methods include error handling. If a notification fails, it will log a warning but won't stop the watcher:</p> <pre><code># This will continue working even if some notifications fail\ncombined_notify = multi_notifier(\n    slack_notify,      # Might fail if webhook is invalid\n    email_notify,      # Might fail if SMTP config is wrong\n    mastodon_notify    # Might fail if token is expired\n)\n</code></pre>"},{"location":"NOTIFICATIONS/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Use Environment Variables: Store sensitive credentials in environment variables, not in code</li> <li>App Passwords: Use app-specific passwords for email services (Gmail, Outlook, etc.)</li> <li>Token Rotation: Regularly rotate API tokens and access keys</li> <li>Webhook Security: Keep webhook URLs secret and regenerate if compromised</li> </ol>"},{"location":"NOTIFICATIONS/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Complete notification example with error handling.\"\"\"\n\nimport os\nfrom glasscandle import Watcher\nfrom glasscandle.notifications import (\n    slack_notifier, email_notifier, mastodon_notifier, \n    bsky_notifier, multi_notifier\n)\n\ndef main():\n    # Set up available notifiers\n    notifiers = []\n\n    try:\n        slack_notify = slack_notifier()\n        notifiers.append(slack_notify)\n        print(\"\u2705 Slack notifications enabled\")\n    except ValueError:\n        print(\"\u274c Slack disabled (set SLACK_WEBHOOK_URL)\")\n\n    try:\n        email_notify = email_notifier()\n        notifiers.append(email_notify)\n        print(\"\u2705 Email notifications enabled\")\n    except ValueError:\n        print(\"\u274c Email disabled (set EMAIL_* variables)\")\n\n    # Add more notifiers as needed...\n\n    if not notifiers:\n        print(\"\u26a0\ufe0f  No notifications configured\")\n        return\n\n    # Combine all available notifiers\n    combined_notify = multi_notifier(*notifiers)\n\n    # Set up watcher\n    watch = Watcher(\"packages.json\")\n    watch.pypi(\"requests\", on_change=combined_notify)\n    watch.pypi(\"django\", on_change=combined_notify)\n\n    print(f\"\ud83d\ude80 Starting watcher with {len(notifiers)} notification method(s)\")\n    watch.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>See <code>examples/notifications_example.py</code> for more detailed examples.</p>"},{"location":"reference/db/","title":"Database","text":""},{"location":"reference/db/#src.glasscandle.db.DB","title":"<code>DB</code>  <code>dataclass</code>","text":"<p>Represents a simple key-value database.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Optional[Path]</code> <p>The path to the database file.</p> <code>db</code> <code>dict</code> <p>The database dictionary.</p> <code>rollback_key</code> <code>Optional[str]</code> <p>The key to rollback in case of an error.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>@dataclass\nclass DB:\n    \"\"\"\n    Represents a simple key-value database.\n\n    Attributes:\n      path (Optional[Path]): The path to the database file.\n      db (dict): The database dictionary.\n      rollback_key (Optional[str]): The key to rollback in case of an error.\n    \"\"\"\n    path: Optional[Path] = None\n    data: dict = field(default_factory=dict)\n    rollback_key: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"\n        Initializes the DB object by creating the database file if it doesn't exist and loading the data from the file.\n        \"\"\"\n        if self.path is None:\n            # use in-memory database if no path is provided\n            return None\n        self.path = Path(self.path)\n        if not self.path.exists():\n            self._create_db()\n        if not self.data:\n            self._load()\n\n    def __iter__(self):\n        \"\"\"\n        Initializes the iterator for the DB object.\n        \"\"\"\n        self.current_index = 0\n        self.keys = list(self.data.keys())\n        return self\n\n    def __next__(self):\n        \"\"\"\n        Retrieves the next key in the database.\n        \"\"\"\n        if self.current_index &lt; len(self.keys):\n            key = self.keys[self.current_index]\n            self.current_index += 1\n            return key\n        raise StopIteration\n\n    def _create_db(self):\n        \"\"\"\n        Creates a new database file and dumps the current database dictionary into it.\n        \"\"\"\n        with open(self.path, \"w\") as f:\n            json.dump(self.data, f)\n\n    def _load(self):\n        \"\"\"\n        Loads the data from the database file into the database dictionary and migrates the data to a new hierarchical structure.\n        \"\"\"\n        if not self.path:\n            return None\n        with open(self.path) as f:\n            db = json.load(f)\n            self.data = db\n        # Migrate old flat structure to new hierarchical structure\n        self._migrate_to_hierarchical()\n\n    def _migrate_to_hierarchical(self):\n        \"\"\"Migrate old flat structure (provider::item) to hierarchical structure.\"\"\"\n        keys_to_migrate = []\n        for key in list(self.data.keys()):\n            if \"::\" in key and not isinstance(self.data[key], dict):\n                keys_to_migrate.append(key)\n\n        for key in keys_to_migrate:\n            provider, item = key.split(\"::\", 1)\n            value = self.data.pop(key)  # Remove old flat key\n            if provider not in self.data:\n                self.data[provider] = {}\n            self.data[provider][item] = value\n\n        # Save the migrated structure if any changes were made\n        if keys_to_migrate:\n            self._save()\n\n    def _save(self):\n        \"\"\"\n        Saves the current database dictionary into the database file and handles exceptions by rolling back changes if necessary.\n        \"\"\"\n        if not self.path:\n            return None\n        try:\n            with open(self.path, \"w\") as f:\n                json.dump(self.data, f, indent=6)\n        except Exception as e:\n            if self.rollback_key:\n                print(f\"Error saving database: {e}. Rolling back key '{self.rollback_key}'.\")\n                del self.data[self.rollback_key]\n                self._save()\n            raise e\n\n\n    def transaction(func):\n        \"\"\"\n        Decorator function for transaction management. Loads data before executing the function, saves data after execution, and returns the result.\n        \"\"\"\n        def wrapper(self, *args, **kwargs):\n            \"\"\"\n            Wrapper function for transaction management. Loads data before executing the function, saves data after execution, and returns the result.\n            \"\"\"\n            self._load()\n            res = func(self, *args, **kwargs)\n            self._save()\n            return res\n        return wrapper\n\n    @transaction\n    def get(self, key):\n        \"\"\"\n        Retrieves the value associated with the given key from the database, supporting both hierarchical and flat key formats.\n        \"\"\"\n        if \"::\" in key:\n            # New hierarchical key format: \"provider::item\" -&gt; [\"provider\"][\"item\"]\n            provider, item = key.split(\"::\", 1)\n            return self.data.get(provider, {}).get(item)\n        else:\n            # Support legacy flat keys for backward compatibility\n            return self.data.get(key)\n\n    @transaction\n    def put(self, key, data):\n        \"\"\"\n        Inserts or updates the value associated with the given key in the database, supporting both hierarchical and flat key formats. Handles rollback in case of an error.\n        \"\"\"\n        self.rollback_key = key\n        if \"::\" in key:\n            # New hierarchical key format: \"provider::item\" -&gt; [\"provider\"][\"item\"]\n            provider, item = key.split(\"::\", 1)\n            if provider not in self.data:\n                self.data[provider] = {}\n            self.data[provider][item] = data\n        else:\n            # Fallback to flat structure for any edge cases\n            self.data[key] = data\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.__iter__","title":"<code>__iter__()</code>","text":"<p>Initializes the iterator for the DB object.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Initializes the iterator for the DB object.\n    \"\"\"\n    self.current_index = 0\n    self.keys = list(self.data.keys())\n    return self\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.__next__","title":"<code>__next__()</code>","text":"<p>Retrieves the next key in the database.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>def __next__(self):\n    \"\"\"\n    Retrieves the next key in the database.\n    \"\"\"\n    if self.current_index &lt; len(self.keys):\n        key = self.keys[self.current_index]\n        self.current_index += 1\n        return key\n    raise StopIteration\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initializes the DB object by creating the database file if it doesn't exist and loading the data from the file.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initializes the DB object by creating the database file if it doesn't exist and loading the data from the file.\n    \"\"\"\n    if self.path is None:\n        # use in-memory database if no path is provided\n        return None\n    self.path = Path(self.path)\n    if not self.path.exists():\n        self._create_db()\n    if not self.data:\n        self._load()\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.get","title":"<code>get(key)</code>","text":"<p>Retrieves the value associated with the given key from the database, supporting both hierarchical and flat key formats.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>@transaction\ndef get(self, key):\n    \"\"\"\n    Retrieves the value associated with the given key from the database, supporting both hierarchical and flat key formats.\n    \"\"\"\n    if \"::\" in key:\n        # New hierarchical key format: \"provider::item\" -&gt; [\"provider\"][\"item\"]\n        provider, item = key.split(\"::\", 1)\n        return self.data.get(provider, {}).get(item)\n    else:\n        # Support legacy flat keys for backward compatibility\n        return self.data.get(key)\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.put","title":"<code>put(key, data)</code>","text":"<p>Inserts or updates the value associated with the given key in the database, supporting both hierarchical and flat key formats. Handles rollback in case of an error.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>@transaction\ndef put(self, key, data):\n    \"\"\"\n    Inserts or updates the value associated with the given key in the database, supporting both hierarchical and flat key formats. Handles rollback in case of an error.\n    \"\"\"\n    self.rollback_key = key\n    if \"::\" in key:\n        # New hierarchical key format: \"provider::item\" -&gt; [\"provider\"][\"item\"]\n        provider, item = key.split(\"::\", 1)\n        if provider not in self.data:\n            self.data[provider] = {}\n        self.data[provider][item] = data\n    else:\n        # Fallback to flat structure for any edge cases\n        self.data[key] = data\n</code></pre>"},{"location":"reference/db/#src.glasscandle.db.DB.transaction","title":"<code>transaction(func)</code>","text":"<p>Decorator function for transaction management. Loads data before executing the function, saves data after execution, and returns the result.</p> Source code in <code>src/glasscandle/db.py</code> <pre><code>def transaction(func):\n    \"\"\"\n    Decorator function for transaction management. Loads data before executing the function, saves data after execution, and returns the result.\n    \"\"\"\n    def wrapper(self, *args, **kwargs):\n        \"\"\"\n        Wrapper function for transaction management. Loads data before executing the function, saves data after execution, and returns the result.\n        \"\"\"\n        self._load()\n        res = func(self, *args, **kwargs)\n        self._save()\n        return res\n    return wrapper\n</code></pre>"},{"location":"reference/external/","title":"External","text":"<p>Mastodon notification functionality.</p> <p>Bluesky (AT Protocol) notification functionality.</p> <p>Email notification functionality.</p>"},{"location":"reference/external/#src.glasscandle.notifications.mastodon.send_mastodon_post","title":"<code>send_mastodon_post(title, content=None, url=None, access_token=None, api_base_url=None)</code>","text":"<p>Send a post to Mastodon.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title/main content of the post</p> required <code>content</code> <code>Optional[str]</code> <p>Additional content (optional)</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>URL to include in the post (optional)</p> <code>None</code> <code>access_token</code> <code>Optional[str]</code> <p>Mastodon access token (if None, uses MASTODON_ACCESS_TOKEN env var)</p> <code>None</code> <code>api_base_url</code> <code>Optional[str]</code> <p>Mastodon instance URL (if None, uses MASTODON_API_BASE_URL env var)</p> <code>None</code> Source code in <code>src/glasscandle/notifications/mastodon.py</code> <pre><code>def send_mastodon_post(\n    title: str, \n    content: Optional[str] = None, \n    url: Optional[str] = None,\n    access_token: Optional[str] = None,\n    api_base_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Send a post to Mastodon.\n\n    Args:\n        title: Title/main content of the post\n        content: Additional content (optional)\n        url: URL to include in the post (optional)\n        access_token: Mastodon access token (if None, uses MASTODON_ACCESS_TOKEN env var)\n        api_base_url: Mastodon instance URL (if None, uses MASTODON_API_BASE_URL env var)\n    \"\"\"\n    try:\n        from mastodon import Mastodon\n    except ImportError:\n        print(\"[ERROR] Mastodon library not installed. Install with: pip install Mastodon.py\")\n        raise\n\n    # Get credentials from environment if not provided\n    if access_token is None:\n        access_token = os.getenv(\"MASTODON_ACCESS_TOKEN\")\n        if not access_token:\n            raise ValueError(\"Mastodon access token must be provided or set in MASTODON_ACCESS_TOKEN environment variable\")\n\n    if api_base_url is None:\n        api_base_url = os.getenv(\"MASTODON_API_BASE_URL\")\n        if not api_base_url:\n            raise ValueError(\"Mastodon API base URL must be provided or set in MASTODON_API_BASE_URL environment variable\")\n\n    # Build the post text\n    post_text = title\n    if content:\n        post_text += f\"\\n\\n{content}\"\n    if url:\n        post_text += f\"\\n\\n\ud83d\udd17 {url}\"\n\n    # Mastodon has a 500 character limit\n    if len(post_text) &gt; 500:\n        post_text = post_text[:497] + \"...\"\n\n    try:\n        mastodon = Mastodon(\n            access_token=access_token,\n            api_base_url=api_base_url\n        )\n        mastodon.toot(post_text)\n    except Exception as e:\n        print(f\"[ERROR] Failed to send Mastodon post: {e}\")\n        raise\n</code></pre>"},{"location":"reference/external/#src.glasscandle.notifications.mastodon.toot","title":"<code>toot(access_token, api_base_url, text)</code>","text":"<p>Legacy function for sending a toot.</p> Source code in <code>src/glasscandle/notifications/mastodon.py</code> <pre><code>def toot(access_token: str, api_base_url: str, text: str) -&gt; None:\n    \"\"\"Legacy function for sending a toot.\"\"\"\n    try:\n        from mastodon import Mastodon\n        mastodon = Mastodon(\n            access_token=access_token,\n            api_base_url=api_base_url\n        )\n        mastodon.toot(text[:499])\n    except Exception as e:\n        print(f\"[ERROR] Failed to send toot: {e}\")\n        raise\n</code></pre>"},{"location":"reference/external/#src.glasscandle.notifications.bsky.send_bsky_post","title":"<code>send_bsky_post(title, content=None, url=None, username=None, password=None, service_url='https://bsky.social')</code>","text":"<p>Send a post to Bluesky via AT Protocol.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title/main content of the post</p> required <code>content</code> <code>Optional[str]</code> <p>Additional content (optional)</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>URL to include in the post (optional)</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>Bluesky username/handle (if None, uses BSKY_USERNAME env var)</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Bluesky password/app password (if None, uses BSKY_PASSWORD env var)</p> <code>None</code> <code>service_url</code> <code>str</code> <p>Bluesky service URL (default: https://bsky.social)</p> <code>'https://bsky.social'</code> Source code in <code>src/glasscandle/notifications/bsky.py</code> <pre><code>def send_bsky_post(\n    title: str,\n    content: Optional[str] = None,\n    url: Optional[str] = None,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    service_url: str = \"https://bsky.social\"\n) -&gt; None:\n    \"\"\"Send a post to Bluesky via AT Protocol.\n\n    Args:\n        title: Title/main content of the post\n        content: Additional content (optional)\n        url: URL to include in the post (optional)\n        username: Bluesky username/handle (if None, uses BSKY_USERNAME env var)\n        password: Bluesky password/app password (if None, uses BSKY_PASSWORD env var)\n        service_url: Bluesky service URL (default: https://bsky.social)\n    \"\"\"\n    # Get credentials from environment if not provided\n    if username is None:\n        username = os.getenv(\"BSKY_USERNAME\")\n        if not username:\n            raise ValueError(\"Bluesky username must be provided or set in BSKY_USERNAME environment variable\")\n\n    if password is None:\n        password = os.getenv(\"BSKY_PASSWORD\")\n        if not password:\n            raise ValueError(\"Bluesky password must be provided or set in BSKY_PASSWORD environment variable\")\n\n    # Build the post text\n    post_text = title\n    if content:\n        post_text += f\"\\n\\n{content}\"\n    if url:\n        post_text += f\"\\n\\n\ud83d\udd17 {url}\"\n\n    # Bluesky has a 300 character limit\n    if len(post_text) &gt; 300:\n        post_text = post_text[:297] + \"...\"\n\n    try:\n        # Create session\n        session_response = requests.post(\n            f\"{service_url}/xrpc/com.atproto.server.createSession\",\n            json={\n                \"identifier\": username,\n                \"password\": password\n            }\n        )\n        session_response.raise_for_status()\n        session_data = session_response.json()\n\n        access_jwt = session_data[\"accessJwt\"]\n        did = session_data[\"did\"]\n\n        # Create post\n        post_response = requests.post(\n            f\"{service_url}/xrpc/com.atproto.repo.createRecord\",\n            headers={\n                \"Authorization\": f\"Bearer {access_jwt}\",\n                \"Content-Type\": \"application/json\"\n            },\n            json={\n                \"repo\": did,\n                \"collection\": \"app.bsky.feed.post\",\n                \"record\": {\n                    \"text\": post_text,\n                    \"createdAt\": datetime.now(timezone.utc).isoformat()\n                }\n            }\n        )\n        post_response.raise_for_status()\n\n    except requests.RequestException as e:\n        print(f\"[ERROR] Failed to send Bluesky post: {e}\")\n        raise\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error sending Bluesky post: {e}\")\n        raise\n</code></pre>"},{"location":"reference/external/#src.glasscandle.notifications.email.send_email","title":"<code>send_email(subject, body, smtp_config={})</code>","text":"<p>Send an email notification.</p> <p>Parameters:</p> Name Type Description Default <code>to</code> <p>Recipient email address</p> required <code>subject</code> <code>str</code> <p>Email subject</p> required <code>body</code> <code>str</code> <p>Email body content</p> required <code>smtp_config</code> <code>Optional[Dict[str, str]]</code> <p>SMTP configuration dictionary containing: - smtp_server: SMTP server hostname - smtp_port: SMTP server port - username: SMTP username - password: SMTP password - from: Sender email address (optional, defaults to username)</p> <code>{}</code> Source code in <code>src/glasscandle/notifications/email.py</code> <pre><code>def send_email(\n    subject: str,\n    body: str,\n    smtp_config: Optional[Dict[str, str]] = {}\n) -&gt; None:\n    \"\"\"Send an email notification.\n\n    Args:\n        to: Recipient email address\n        subject: Email subject\n        body: Email body content\n        smtp_config: SMTP configuration dictionary containing:\n            - smtp_server: SMTP server hostname\n            - smtp_port: SMTP server port\n            - username: SMTP username\n            - password: SMTP password\n            - from: Sender email address (optional, defaults to username)\n    \"\"\"\n    smtp_config = {\n        \"to\": smtp_config.get(\"to\") or os.getenv(\"EMAIL_TO\"),\n        \"from\": smtp_config.get(\"from\") or os.getenv(\"EMAIL_FROM\"),\n        \"smtp_server\": smtp_config.get(\"smtp_server\") or os.getenv(\"EMAIL_SMTP_SERVER\"),\n        \"smtp_port\": int(smtp_config.get(\"smtp_port\") or os.getenv(\"EMAIL_SMTP_PORT\", \"587\")),\n        \"username\": smtp_config.get(\"username\") or os.getenv(\"EMAIL_USERNAME\"),\n        \"password\": smtp_config.get(\"password\") or os.getenv(\"EMAIL_PASSWORD\"),\n    }\n    if not smtp_config.get(\"to\") or not smtp_config.get(\"username\") or not smtp_config.get(\"password\"):\n        raise ValueError(\"Missing required email configuration: to, username, and password must be set.\")\n\n    from_email = smtp_config.get(\"from\", smtp_config[\"username\"])\n    to = smtp_config[\"to\"]\n\n    # Create message\n    message = MIMEMultipart()\n    message[\"From\"] = from_email\n    message[\"To\"] = to\n    message[\"Subject\"] = subject\n\n    # Add body to email\n    message.attach(MIMEText(body, \"plain\"))\n\n    # Create secure connection and send email\n    try:\n        # Create SSL context\n        context = ssl.create_default_context()\n\n        # Connect to server\n        with smtplib.SMTP(smtp_config[\"smtp_server\"], smtp_config[\"smtp_port\"]) as server:\n            server.starttls(context=context)\n            server.login(smtp_config[\"username\"], smtp_config[\"password\"])\n\n            # Send email\n            text = message.as_string()\n            server.sendmail(from_email, to, text)\n\n    except Exception as e:\n        print(f\"[ERROR] Failed to send email: {e}\")\n        raise\n</code></pre>"},{"location":"reference/external/#src.glasscandle.notifications.slack.send_slack_msg","title":"<code>send_slack_msg(title, content=None, url=None, webhook_url=None)</code>","text":"<p>Send a message to a Slack channel via webhook.</p> <p>Parameters:</p> Name Type Description Default <code>hook_url</code> <p>Slack webhook URL</p> required <code>title</code> <code>str</code> <p>Title of the message</p> required <code>content</code> <code>str</code> <p>Optional Content of the message</p> <code>None</code> <code>url</code> <code>str</code> <p>Optional URL to include in the message</p> <code>None</code> Source code in <code>src/glasscandle/notifications/slack.py</code> <pre><code>def send_slack_msg(title: str, content: str = None, url: str = None, webhook_url = None) -&gt; None:\n    \"\"\"Send a message to a Slack channel via webhook.\n    Args:\n        hook_url: Slack webhook URL\n        title: Title of the message\n        content: Optional Content of the message\n        url: Optional URL to include in the message\n    \"\"\"\n    if not webhook_url:\n        webhook_url = os.getenv(\"SLACK_WEBHOOK_URL\")\n    if not webhook_url:\n        raise ValueError(\"Slack webhook URL must be provided or set in SLACK_WEBHOOK_URL environment variable\")\n\n    data = {\n        \"text\": title,\n        \"blocks\": [\n            {\n                    \"type\": \"section\",\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": title\n                    }\n                },\n        ]\n    }\n    if content:\n        data[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": content\n            }\n        })\n    if url:\n        data[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"Click here for more details -&gt; {url}\"\n            }\n        })\n    try:\n        r = requests.post(webhook_url, json=data)\n        r.raise_for_status()\n    except requests.RequestException as e:\n        print(f\"[ERROR] Failed to send Slack message: {e}\")\n        raise\n</code></pre>"},{"location":"reference/http/","title":"HTTP","text":"<p>HTTP utilities and session management.</p>"},{"location":"reference/http/#src.glasscandle.http.create_session","title":"<code>create_session()</code>","text":"<p>Create a configured requests session with retries.</p> Source code in <code>src/glasscandle/http.py</code> <pre><code>def create_session() -&gt; requests.Session:\n    \"\"\"Create a configured requests session with retries.\"\"\"\n    s = requests.Session()\n    s.headers.update(\n        {\n            \"User-Agent\": \"watcher/1.0 (+https://example.org); requests\",\n            \"Accept\": \"application/json, text/html;q=0.9, */*;q=0.1\",\n        }\n    )\n    retries = Retry(\n        total=3,\n        backoff_factor=0.3,\n        status_forcelist=(429, 500, 502, 503, 504),\n        allowed_methods=frozenset([\"GET\", \"HEAD\"]),\n        raise_on_redirect=False,\n        raise_on_status=False,\n    )\n    s.mount(\"https://\", HTTPAdapter(max_retries=retries))\n    s.mount(\"http://\", HTTPAdapter(max_retries=retries))\n    return s\n</code></pre>"},{"location":"reference/notifications/","title":"Notifications","text":"<p>Mastodon notification functionality.</p> <p>Bluesky (AT Protocol) notification functionality.</p> <p>Email notification functionality.</p>"},{"location":"reference/notifications/#src.glasscandle.notifications.mastodon.send_mastodon_post","title":"<code>send_mastodon_post(title, content=None, url=None, access_token=None, api_base_url=None)</code>","text":"<p>Send a post to Mastodon.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title/main content of the post</p> required <code>content</code> <code>Optional[str]</code> <p>Additional content (optional)</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>URL to include in the post (optional)</p> <code>None</code> <code>access_token</code> <code>Optional[str]</code> <p>Mastodon access token (if None, uses MASTODON_ACCESS_TOKEN env var)</p> <code>None</code> <code>api_base_url</code> <code>Optional[str]</code> <p>Mastodon instance URL (if None, uses MASTODON_API_BASE_URL env var)</p> <code>None</code> Source code in <code>src/glasscandle/notifications/mastodon.py</code> <pre><code>def send_mastodon_post(\n    title: str, \n    content: Optional[str] = None, \n    url: Optional[str] = None,\n    access_token: Optional[str] = None,\n    api_base_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Send a post to Mastodon.\n\n    Args:\n        title: Title/main content of the post\n        content: Additional content (optional)\n        url: URL to include in the post (optional)\n        access_token: Mastodon access token (if None, uses MASTODON_ACCESS_TOKEN env var)\n        api_base_url: Mastodon instance URL (if None, uses MASTODON_API_BASE_URL env var)\n    \"\"\"\n    try:\n        from mastodon import Mastodon\n    except ImportError:\n        print(\"[ERROR] Mastodon library not installed. Install with: pip install Mastodon.py\")\n        raise\n\n    # Get credentials from environment if not provided\n    if access_token is None:\n        access_token = os.getenv(\"MASTODON_ACCESS_TOKEN\")\n        if not access_token:\n            raise ValueError(\"Mastodon access token must be provided or set in MASTODON_ACCESS_TOKEN environment variable\")\n\n    if api_base_url is None:\n        api_base_url = os.getenv(\"MASTODON_API_BASE_URL\")\n        if not api_base_url:\n            raise ValueError(\"Mastodon API base URL must be provided or set in MASTODON_API_BASE_URL environment variable\")\n\n    # Build the post text\n    post_text = title\n    if content:\n        post_text += f\"\\n\\n{content}\"\n    if url:\n        post_text += f\"\\n\\n\ud83d\udd17 {url}\"\n\n    # Mastodon has a 500 character limit\n    if len(post_text) &gt; 500:\n        post_text = post_text[:497] + \"...\"\n\n    try:\n        mastodon = Mastodon(\n            access_token=access_token,\n            api_base_url=api_base_url\n        )\n        mastodon.toot(post_text)\n    except Exception as e:\n        print(f\"[ERROR] Failed to send Mastodon post: {e}\")\n        raise\n</code></pre>"},{"location":"reference/notifications/#src.glasscandle.notifications.mastodon.toot","title":"<code>toot(access_token, api_base_url, text)</code>","text":"<p>Legacy function for sending a toot.</p> Source code in <code>src/glasscandle/notifications/mastodon.py</code> <pre><code>def toot(access_token: str, api_base_url: str, text: str) -&gt; None:\n    \"\"\"Legacy function for sending a toot.\"\"\"\n    try:\n        from mastodon import Mastodon\n        mastodon = Mastodon(\n            access_token=access_token,\n            api_base_url=api_base_url\n        )\n        mastodon.toot(text[:499])\n    except Exception as e:\n        print(f\"[ERROR] Failed to send toot: {e}\")\n        raise\n</code></pre>"},{"location":"reference/notifications/#src.glasscandle.notifications.bsky.send_bsky_post","title":"<code>send_bsky_post(title, content=None, url=None, username=None, password=None, service_url='https://bsky.social')</code>","text":"<p>Send a post to Bluesky via AT Protocol.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title/main content of the post</p> required <code>content</code> <code>Optional[str]</code> <p>Additional content (optional)</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>URL to include in the post (optional)</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>Bluesky username/handle (if None, uses BSKY_USERNAME env var)</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Bluesky password/app password (if None, uses BSKY_PASSWORD env var)</p> <code>None</code> <code>service_url</code> <code>str</code> <p>Bluesky service URL (default: https://bsky.social)</p> <code>'https://bsky.social'</code> Source code in <code>src/glasscandle/notifications/bsky.py</code> <pre><code>def send_bsky_post(\n    title: str,\n    content: Optional[str] = None,\n    url: Optional[str] = None,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    service_url: str = \"https://bsky.social\"\n) -&gt; None:\n    \"\"\"Send a post to Bluesky via AT Protocol.\n\n    Args:\n        title: Title/main content of the post\n        content: Additional content (optional)\n        url: URL to include in the post (optional)\n        username: Bluesky username/handle (if None, uses BSKY_USERNAME env var)\n        password: Bluesky password/app password (if None, uses BSKY_PASSWORD env var)\n        service_url: Bluesky service URL (default: https://bsky.social)\n    \"\"\"\n    # Get credentials from environment if not provided\n    if username is None:\n        username = os.getenv(\"BSKY_USERNAME\")\n        if not username:\n            raise ValueError(\"Bluesky username must be provided or set in BSKY_USERNAME environment variable\")\n\n    if password is None:\n        password = os.getenv(\"BSKY_PASSWORD\")\n        if not password:\n            raise ValueError(\"Bluesky password must be provided or set in BSKY_PASSWORD environment variable\")\n\n    # Build the post text\n    post_text = title\n    if content:\n        post_text += f\"\\n\\n{content}\"\n    if url:\n        post_text += f\"\\n\\n\ud83d\udd17 {url}\"\n\n    # Bluesky has a 300 character limit\n    if len(post_text) &gt; 300:\n        post_text = post_text[:297] + \"...\"\n\n    try:\n        # Create session\n        session_response = requests.post(\n            f\"{service_url}/xrpc/com.atproto.server.createSession\",\n            json={\n                \"identifier\": username,\n                \"password\": password\n            }\n        )\n        session_response.raise_for_status()\n        session_data = session_response.json()\n\n        access_jwt = session_data[\"accessJwt\"]\n        did = session_data[\"did\"]\n\n        # Create post\n        post_response = requests.post(\n            f\"{service_url}/xrpc/com.atproto.repo.createRecord\",\n            headers={\n                \"Authorization\": f\"Bearer {access_jwt}\",\n                \"Content-Type\": \"application/json\"\n            },\n            json={\n                \"repo\": did,\n                \"collection\": \"app.bsky.feed.post\",\n                \"record\": {\n                    \"text\": post_text,\n                    \"createdAt\": datetime.now(timezone.utc).isoformat()\n                }\n            }\n        )\n        post_response.raise_for_status()\n\n    except requests.RequestException as e:\n        print(f\"[ERROR] Failed to send Bluesky post: {e}\")\n        raise\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error sending Bluesky post: {e}\")\n        raise\n</code></pre>"},{"location":"reference/notifications/#src.glasscandle.notifications.email.send_email","title":"<code>send_email(subject, body, smtp_config={})</code>","text":"<p>Send an email notification.</p> <p>Parameters:</p> Name Type Description Default <code>to</code> <p>Recipient email address</p> required <code>subject</code> <code>str</code> <p>Email subject</p> required <code>body</code> <code>str</code> <p>Email body content</p> required <code>smtp_config</code> <code>Optional[Dict[str, str]]</code> <p>SMTP configuration dictionary containing: - smtp_server: SMTP server hostname - smtp_port: SMTP server port - username: SMTP username - password: SMTP password - from: Sender email address (optional, defaults to username)</p> <code>{}</code> Source code in <code>src/glasscandle/notifications/email.py</code> <pre><code>def send_email(\n    subject: str,\n    body: str,\n    smtp_config: Optional[Dict[str, str]] = {}\n) -&gt; None:\n    \"\"\"Send an email notification.\n\n    Args:\n        to: Recipient email address\n        subject: Email subject\n        body: Email body content\n        smtp_config: SMTP configuration dictionary containing:\n            - smtp_server: SMTP server hostname\n            - smtp_port: SMTP server port\n            - username: SMTP username\n            - password: SMTP password\n            - from: Sender email address (optional, defaults to username)\n    \"\"\"\n    smtp_config = {\n        \"to\": smtp_config.get(\"to\") or os.getenv(\"EMAIL_TO\"),\n        \"from\": smtp_config.get(\"from\") or os.getenv(\"EMAIL_FROM\"),\n        \"smtp_server\": smtp_config.get(\"smtp_server\") or os.getenv(\"EMAIL_SMTP_SERVER\"),\n        \"smtp_port\": int(smtp_config.get(\"smtp_port\") or os.getenv(\"EMAIL_SMTP_PORT\", \"587\")),\n        \"username\": smtp_config.get(\"username\") or os.getenv(\"EMAIL_USERNAME\"),\n        \"password\": smtp_config.get(\"password\") or os.getenv(\"EMAIL_PASSWORD\"),\n    }\n    if not smtp_config.get(\"to\") or not smtp_config.get(\"username\") or not smtp_config.get(\"password\"):\n        raise ValueError(\"Missing required email configuration: to, username, and password must be set.\")\n\n    from_email = smtp_config.get(\"from\", smtp_config[\"username\"])\n    to = smtp_config[\"to\"]\n\n    # Create message\n    message = MIMEMultipart()\n    message[\"From\"] = from_email\n    message[\"To\"] = to\n    message[\"Subject\"] = subject\n\n    # Add body to email\n    message.attach(MIMEText(body, \"plain\"))\n\n    # Create secure connection and send email\n    try:\n        # Create SSL context\n        context = ssl.create_default_context()\n\n        # Connect to server\n        with smtplib.SMTP(smtp_config[\"smtp_server\"], smtp_config[\"smtp_port\"]) as server:\n            server.starttls(context=context)\n            server.login(smtp_config[\"username\"], smtp_config[\"password\"])\n\n            # Send email\n            text = message.as_string()\n            server.sendmail(from_email, to, text)\n\n    except Exception as e:\n        print(f\"[ERROR] Failed to send email: {e}\")\n        raise\n</code></pre>"},{"location":"reference/notifications/#src.glasscandle.notifications.slack.send_slack_msg","title":"<code>send_slack_msg(title, content=None, url=None, webhook_url=None)</code>","text":"<p>Send a message to a Slack channel via webhook.</p> <p>Parameters:</p> Name Type Description Default <code>hook_url</code> <p>Slack webhook URL</p> required <code>title</code> <code>str</code> <p>Title of the message</p> required <code>content</code> <code>str</code> <p>Optional Content of the message</p> <code>None</code> <code>url</code> <code>str</code> <p>Optional URL to include in the message</p> <code>None</code> Source code in <code>src/glasscandle/notifications/slack.py</code> <pre><code>def send_slack_msg(title: str, content: str = None, url: str = None, webhook_url = None) -&gt; None:\n    \"\"\"Send a message to a Slack channel via webhook.\n    Args:\n        hook_url: Slack webhook URL\n        title: Title of the message\n        content: Optional Content of the message\n        url: Optional URL to include in the message\n    \"\"\"\n    if not webhook_url:\n        webhook_url = os.getenv(\"SLACK_WEBHOOK_URL\")\n    if not webhook_url:\n        raise ValueError(\"Slack webhook URL must be provided or set in SLACK_WEBHOOK_URL environment variable\")\n\n    data = {\n        \"text\": title,\n        \"blocks\": [\n            {\n                    \"type\": \"section\",\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": title\n                    }\n                },\n        ]\n    }\n    if content:\n        data[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": content\n            }\n        })\n    if url:\n        data[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"Click here for more details -&gt; {url}\"\n            }\n        })\n    try:\n        r = requests.post(webhook_url, json=data)\n        r.raise_for_status()\n    except requests.RequestException as e:\n        print(f\"[ERROR] Failed to send Slack message: {e}\")\n        raise\n</code></pre>"},{"location":"reference/parsers/","title":"Parsers","text":"<p>Response parsing functions for various types of content.</p>"},{"location":"reference/parsers/#src.glasscandle.parsers.etag","title":"<code>etag(res)</code>","text":"<p>Extract and normalize ETag header.</p> Source code in <code>src/glasscandle/parsers.py</code> <pre><code>def etag(res: requests.Response) -&gt; str:\n    \"\"\"Extract and normalize ETag header.\"\"\"\n    val = res.headers.get(\"ETag\")\n    if not val:\n        raise ValueError(\"No ETag header\")\n    # normalize: strip weak prefix and surrounding quotes\n    v = val.strip()\n    if v.startswith(\"W/\"):\n        v = v[2:]\n    v = v.strip('\"').strip()\n    if not v:\n        raise ValueError(\"Empty ETag after normalization\")\n    return v\n</code></pre>"},{"location":"reference/parsers/#src.glasscandle.parsers.jsonpath","title":"<code>jsonpath(path)</code>","text":"<p>Create a JSONPath parser for JSON response content.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>JSONPath expression to extract the value (e.g., \"$.version\", \"$.data[0].tag_name\")</p> required <p>Returns:</p> Type Description <code>Callable[[requests.Response], str]</code> <p>Parser function that extracts the value using the JSONPath expression</p> Source code in <code>src/glasscandle/parsers.py</code> <pre><code>def jsonpath(path: str) -&gt; Callable[[requests.Response], str]:\n    \"\"\"Create a JSONPath parser for JSON response content.\n\n    Args:\n        path: JSONPath expression to extract the value (e.g., \"$.version\", \"$.data[0].tag_name\")\n\n    Returns:\n        Parser function that extracts the value using the JSONPath expression\n    \"\"\"\n    def _parse(res: requests.Response) -&gt; str:\n        \"\"\"\n    Parses the response content using the provided parsing function.\n\n    Args:\n      response (requests.Response): The response object to parse.\n      parse_func (Callable): The parsing function to use.\n\n    Returns:\n      Any: The parsed content.\n\n    Examples:\n      &gt;&gt;&gt; _parse(response, json.loads)\n      {'key': 'value'}\n    \"\"\"\n        try:\n            data = res.json()\n        except ValueError as e:\n            raise ValueError(f\"Invalid JSON response: {e}\")\n\n        # Simple JSONPath implementation for basic expressions\n        # Supports: $.key, $.key.subkey, $.array[0], $.array[0].key\n        value = data\n        parts = path.strip(\"$\").strip(\".\").split(\".\")\n\n        for part in parts:\n            if not part:\n                continue\n\n            # Handle array indexing like \"array[0]\"\n            if \"[\" in part and \"]\" in part:\n                key, bracket = part.split(\"[\", 1)\n                index = int(bracket.rstrip(\"]\"))\n                if key:\n                    value = value[key]\n                value = value[index]\n            else:\n                value = value[part]\n\n        result = str(value).strip()\n        if not result:\n            raise ValueError(f\"JSONPath {path!r} returned empty value\")\n        return result\n\n    return _parse\n</code></pre>"},{"location":"reference/parsers/#src.glasscandle.parsers.last_modified","title":"<code>last_modified(res)</code>","text":"<p>Extract Last-Modified header.</p> Source code in <code>src/glasscandle/parsers.py</code> <pre><code>def last_modified(res: requests.Response) -&gt; str:\n    \"\"\"Extract Last-Modified header.\"\"\"\n    lm = res.headers.get(\"Last-Modified\", \"\")\n    if not lm:\n        raise ValueError(\"No Last-Modified header\")\n    return lm\n</code></pre>"},{"location":"reference/parsers/#src.glasscandle.parsers.regex","title":"<code>regex(pattern, group=1)</code>","text":"<p>Create a regex parser for response content.</p> Source code in <code>src/glasscandle/parsers.py</code> <pre><code>def regex(pattern: str, group: int = 1) -&gt; Callable[[requests.Response], str]:\n    \"\"\"Create a regex parser for response content.\"\"\"\n    rx = re.compile(pattern, re.M | re.S)\n\n    def _parse(res: requests.Response) -&gt; str:\n        \"\"\"\n    Parses the response content using the provided parsing function.\n\n    Args:\n      response (requests.Response): The response object to parse.\n      parse_func (Callable): The parsing function to use.\n\n    Returns:\n      Any: The parsed content.\n\n    Examples:\n      &gt;&gt;&gt; _parse(response, json.loads)\n      {'key': 'value'}\n    \"\"\"\n        ctype = res.headers.get(\"Content-Type\", \"\")\n        # Optional guard: only attempt text or json\n        if (\"text\" not in ctype) and (\"json\" not in ctype):\n            # still attempt decode, but signal that this might be wrong\n            pass\n        text = res.text  # requests decodes using apparent encoding\n        m = rx.search(text)\n        if not m:\n            raise ValueError(f\"Pattern {pattern!r} not found\")\n        try:\n            out = m.group(group)\n        except IndexError:\n            raise ValueError(f\"Group {group} not present in match\")\n        out = out.strip()\n        if not out:\n            raise ValueError(\"Empty capture\")\n        return out\n\n    return _parse\n</code></pre>"},{"location":"reference/parsers/#src.glasscandle.parsers.sha256_of_body","title":"<code>sha256_of_body(res)</code>","text":"<p>Calculate SHA256 hash of response body.</p> Source code in <code>src/glasscandle/parsers.py</code> <pre><code>def sha256_of_body(res: requests.Response) -&gt; str:\n    \"\"\"Calculate SHA256 hash of response body.\"\"\"\n    # Warning: URLProvider should HEAD\u2011check size before calling this.\n    return _sha256(res.content).hexdigest()\n</code></pre>"},{"location":"reference/pool/","title":"Pool","text":"<p>Provider pool for managing collections of different provider types.</p>"},{"location":"reference/pool/#src.glasscandle.pool.Pool","title":"<code>Pool</code>  <code>dataclass</code>","text":"<p>Collection of all registered providers by type.</p> Source code in <code>src/glasscandle/pool.py</code> <pre><code>@dataclass\nclass Pool:\n    \"\"\"Collection of all registered providers by type.\"\"\"\n    conda: Dict[str, CondaProvider] = field(default_factory=dict)\n    bioconda: Dict[str, BiocondaProvider] = field(default_factory=dict)\n    condaforge: Dict[str, CondaForgeProvider] = field(default_factory=dict)\n    pypi: Dict[str, PyPIProvider] = field(default_factory=dict)\n    url: Dict[str, URLProvider] = field(default_factory=dict)\n    custom: Dict[str, CustomFunc] = field(default_factory=dict)\n    custom_callbacks: Dict[str, Optional[OnChangeFunc]] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/providers/","title":"Providers","text":"<p>Conda provider for checking conda package versions across multiple channels.</p> <p>Bioconda provider for checking conda package versions.</p> <p>Conda-forge provider for checking conda package versions.</p> <p>URL provider for checking arbitrary URLs with custom parsers.</p> <p>PyPI provider for checking Python package versions.</p> <p>Base provider protocol and constants.</p>"},{"location":"reference/providers/#src.glasscandle.providers.conda.CondaProvider","title":"<code>CondaProvider</code>  <code>dataclass</code>","text":"<p>Conda provider for checking conda package versions across multiple channels.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the provider. Default is \"conda\".</p> <code>channels</code> <code>List[str]</code> <p>List of conda channels to search. Default is [\"conda-forge\", \"bioconda\"].</p> <code>version_constraint</code> <code>Optional[str]</code> <p>Version constraint string (e.g., \"&gt;=1.21,&lt;2\").</p> <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Optional callback function to be called on change.</p> Methods <p>key(item: str) -&gt; str:     Returns the key for the given item.</p> <p>parse_package_spec(item: str) -&gt; Tuple[str, List[str]]:     Parse package specification to extract package name and channels.</p> <pre><code>Supports formats:\n- \"package_name\" -&gt; uses default channels\n- \"channel::package_name\" -&gt; uses specified channel only\n</code></pre> <p>url_for(item: str, channel: str) -&gt; str:     Returns the URL for the given item in the specified channel.</p> <p>fetch_version(item: str, session: requests.Session) -&gt; str:     Fetches the version of the given item from conda channels.</p> <pre><code>Searches channels in order until package is found.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; provider = CondaProvider()\n&gt;&gt;&gt; version = provider.fetch_version(\"samtools\", requests.Session())\n\"1.17\"\n</code></pre> <pre><code>&gt;&gt;&gt; provider = CondaProvider(channels=[\"bioconda\"], version_constraint=\"&gt;=1.15,&lt;2\")\n&gt;&gt;&gt; version = provider.fetch_version(\"blast\", requests.Session())\n\"1.17\"  # Only if version matches constraint\n</code></pre> Source code in <code>src/glasscandle/providers/conda.py</code> <pre><code>@dataclass\nclass CondaProvider:\n    \"\"\"\n    Conda provider for checking conda package versions across multiple channels.\n\n    Attributes:\n        name (str): The name of the provider. Default is \"conda\".\n        channels (List[str]): List of conda channels to search. Default is [\"conda-forge\", \"bioconda\"].\n        version_constraint (Optional[str]): Version constraint string (e.g., \"&gt;=1.21,&lt;2\").\n        on_change (Optional[Callable[[str, str, str], None]]): Optional callback function to be called on change.\n\n    Methods:\n        key(item: str) -&gt; str:\n            Returns the key for the given item.\n\n        parse_package_spec(item: str) -&gt; Tuple[str, List[str]]:\n            Parse package specification to extract package name and channels.\n\n            Supports formats:\n            - \"package_name\" -&gt; uses default channels\n            - \"channel::package_name\" -&gt; uses specified channel only\n\n        url_for(item: str, channel: str) -&gt; str:\n            Returns the URL for the given item in the specified channel.\n\n        fetch_version(item: str, session: requests.Session) -&gt; str:\n            Fetches the version of the given item from conda channels.\n\n            Searches channels in order until package is found.\n\n    Examples:\n        &gt;&gt;&gt; provider = CondaProvider()\n        &gt;&gt;&gt; version = provider.fetch_version(\"samtools\", requests.Session())\n        \"1.17\"\n\n        &gt;&gt;&gt; provider = CondaProvider(channels=[\"bioconda\"], version_constraint=\"&gt;=1.15,&lt;2\")\n        &gt;&gt;&gt; version = provider.fetch_version(\"blast\", requests.Session())\n        \"1.17\"  # Only if version matches constraint\n    \"\"\"\n    name: str = \"conda\"\n    channels: List[str] = None\n    version_constraint: Optional[str] = None\n    on_change: Optional[Callable[[str, str, str], None]] = None\n\n    def __post_init__(self):\n        if self.channels is None:\n            self.channels = [\"conda-forge\", \"bioconda\"]\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"Generate database key for the package.\"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"{self.name}::{package_name}\"\n\n    def parse_package_spec(self, item: str) -&gt; Tuple[str, List[str]]:\n        \"\"\"\n        Parse package specification to extract package name and channels.\n\n        Args:\n            item: Package specification (e.g., \"samtools\", \"bioconda::samtools\")\n\n        Returns:\n            Tuple of (package_name, channels_to_search)\n        \"\"\"\n        if \"::\" in item:\n            channel, package_name = item.split(\"::\", 1)\n            return package_name, [channel]\n        else:\n            return item, self.channels\n\n    def url_for(self, item: str, channel: str) -&gt; str:\n        \"\"\"\n        Generate API URL for package in specific channel.\n\n        Args:\n            item: Package name\n            channel: Conda channel name\n\n        Returns:\n            API URL for the package in the channel\n        \"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n\n    def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n        \"\"\"\n        Fetch the latest version of a conda package.\n\n        Searches through channels in order until package is found.\n        Applies version constraints if specified.\n\n        Args:\n            item: Package specification\n            session: HTTP session for requests\n\n        Returns:\n            Latest version string that matches constraints\n\n        Raises:\n            ValueError: If package not found in any channel or no version matches constraints\n        \"\"\"\n        from ..http import HTTP_TIMEOUT\n        from ..version_constraints import VersionConstraint\n\n        package_name, channels_to_search = self.parse_package_spec(item)\n\n        # Initialize version constraint if specified\n        constraint = None\n        if self.version_constraint:\n            try:\n                constraint = VersionConstraint(self.version_constraint)\n            except Exception as e:\n                raise ValueError(f\"Invalid version constraint '{self.version_constraint}': {e}\")\n\n        last_error = None\n        for channel in channels_to_search:\n            try:\n                url = self.url_for(package_name, channel)\n                r = session.get(url, timeout=HTTP_TIMEOUT)\n\n                if r.status_code == 404:\n                    last_error = f\"{package_name} not found in channel {channel}\"\n                    continue\n\n                if r.status_code != 200:\n                    last_error = f\"{url} returned {r.status_code}\"\n                    continue\n\n                data = r.json()\n\n                # Get all available versions\n                all_versions = data.get(\"versions\") or []\n                if not all_versions:\n                    # If no versions list, try latest_version\n                    latest = data.get(\"latest_version\")\n                    if latest:\n                        all_versions = [latest]\n\n                if not all_versions:\n                    last_error = f\"No versions for {package_name} in channel {channel}\"\n                    continue\n\n                # Apply version constraints if specified\n                if constraint:\n                    valid_version = constraint.get_latest_valid(all_versions)\n                    if valid_version:\n                        return valid_version\n                    else:\n                        last_error = f\"No versions for {package_name} in channel {channel} match constraint '{self.version_constraint}'\"\n                        continue\n                else:\n                    # No constraints, return latest version\n                    latest_version = data.get(\"latest_version\")\n                    if latest_version:\n                        return latest_version\n                    else:\n                        # Fall back to max of versions if latest_version not available\n                        return max(all_versions)\n\n            except Exception as e:\n                last_error = f\"Error fetching {package_name} from {channel}: {e}\"\n                continue\n\n        # If we get here, package wasn't found in any channel or no versions matched constraints\n        channels_str = \", \".join(channels_to_search)\n        constraint_str = f\" matching constraint '{self.version_constraint}'\" if self.version_constraint else \"\"\n        raise ValueError(f\"{package_name} not found{constraint_str} in any of the channels: {channels_str}. Last error: {last_error}\")\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.conda.CondaProvider.fetch_version","title":"<code>fetch_version(item, session)</code>","text":"<p>Fetch the latest version of a conda package.</p> <p>Searches through channels in order until package is found. Applies version constraints if specified.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Package specification</p> required <code>session</code> <code>requests.Session</code> <p>HTTP session for requests</p> required <p>Returns:</p> Type Description <code>str</code> <p>Latest version string that matches constraints</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If package not found in any channel or no version matches constraints</p> Source code in <code>src/glasscandle/providers/conda.py</code> <pre><code>def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n    \"\"\"\n    Fetch the latest version of a conda package.\n\n    Searches through channels in order until package is found.\n    Applies version constraints if specified.\n\n    Args:\n        item: Package specification\n        session: HTTP session for requests\n\n    Returns:\n        Latest version string that matches constraints\n\n    Raises:\n        ValueError: If package not found in any channel or no version matches constraints\n    \"\"\"\n    from ..http import HTTP_TIMEOUT\n    from ..version_constraints import VersionConstraint\n\n    package_name, channels_to_search = self.parse_package_spec(item)\n\n    # Initialize version constraint if specified\n    constraint = None\n    if self.version_constraint:\n        try:\n            constraint = VersionConstraint(self.version_constraint)\n        except Exception as e:\n            raise ValueError(f\"Invalid version constraint '{self.version_constraint}': {e}\")\n\n    last_error = None\n    for channel in channels_to_search:\n        try:\n            url = self.url_for(package_name, channel)\n            r = session.get(url, timeout=HTTP_TIMEOUT)\n\n            if r.status_code == 404:\n                last_error = f\"{package_name} not found in channel {channel}\"\n                continue\n\n            if r.status_code != 200:\n                last_error = f\"{url} returned {r.status_code}\"\n                continue\n\n            data = r.json()\n\n            # Get all available versions\n            all_versions = data.get(\"versions\") or []\n            if not all_versions:\n                # If no versions list, try latest_version\n                latest = data.get(\"latest_version\")\n                if latest:\n                    all_versions = [latest]\n\n            if not all_versions:\n                last_error = f\"No versions for {package_name} in channel {channel}\"\n                continue\n\n            # Apply version constraints if specified\n            if constraint:\n                valid_version = constraint.get_latest_valid(all_versions)\n                if valid_version:\n                    return valid_version\n                else:\n                    last_error = f\"No versions for {package_name} in channel {channel} match constraint '{self.version_constraint}'\"\n                    continue\n            else:\n                # No constraints, return latest version\n                latest_version = data.get(\"latest_version\")\n                if latest_version:\n                    return latest_version\n                else:\n                    # Fall back to max of versions if latest_version not available\n                    return max(all_versions)\n\n        except Exception as e:\n            last_error = f\"Error fetching {package_name} from {channel}: {e}\"\n            continue\n\n    # If we get here, package wasn't found in any channel or no versions matched constraints\n    channels_str = \", \".join(channels_to_search)\n    constraint_str = f\" matching constraint '{self.version_constraint}'\" if self.version_constraint else \"\"\n    raise ValueError(f\"{package_name} not found{constraint_str} in any of the channels: {channels_str}. Last error: {last_error}\")\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.conda.CondaProvider.key","title":"<code>key(item)</code>","text":"<p>Generate database key for the package.</p> Source code in <code>src/glasscandle/providers/conda.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"Generate database key for the package.\"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"{self.name}::{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.conda.CondaProvider.parse_package_spec","title":"<code>parse_package_spec(item)</code>","text":"<p>Parse package specification to extract package name and channels.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Package specification (e.g., \"samtools\", \"bioconda::samtools\")</p> required <p>Returns:</p> Type Description <code>Tuple[str, List[str]]</code> <p>Tuple of (package_name, channels_to_search)</p> Source code in <code>src/glasscandle/providers/conda.py</code> <pre><code>def parse_package_spec(self, item: str) -&gt; Tuple[str, List[str]]:\n    \"\"\"\n    Parse package specification to extract package name and channels.\n\n    Args:\n        item: Package specification (e.g., \"samtools\", \"bioconda::samtools\")\n\n    Returns:\n        Tuple of (package_name, channels_to_search)\n    \"\"\"\n    if \"::\" in item:\n        channel, package_name = item.split(\"::\", 1)\n        return package_name, [channel]\n    else:\n        return item, self.channels\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.conda.CondaProvider.url_for","title":"<code>url_for(item, channel)</code>","text":"<p>Generate API URL for package in specific channel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Package name</p> required <code>channel</code> <code>str</code> <p>Conda channel name</p> required <p>Returns:</p> Type Description <code>str</code> <p>API URL for the package in the channel</p> Source code in <code>src/glasscandle/providers/conda.py</code> <pre><code>def url_for(self, item: str, channel: str) -&gt; str:\n    \"\"\"\n    Generate API URL for package in specific channel.\n\n    Args:\n        item: Package name\n        channel: Conda channel name\n\n    Returns:\n        API URL for the package in the channel\n    \"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.bioconda.BiocondaProvider","title":"<code>BiocondaProvider</code>  <code>dataclass</code>","text":"<p>             Bases: <code>CondaProvider</code></p> <p>Bioconda provider for checking conda package versions.</p> <p>This is a specialized version of CondaProvider that only searches the bioconda channel and maintains backward compatibility with the original bioconda provider.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the provider. Default is \"bioconda\".</p> <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Optional callback function to be called on change.</p> Methods <p>key(item: str) -&gt; str:   Returns the key for the given item.</p> <p>Args:     item (str): The item to generate the key for.</p> <p>Returns:     str: The key for the item.</p> <p>fetch_version(item: str, session: requests.Session) -&gt; str:   Fetches the version of the given item from bioconda.</p> <p>Args:     item (str): The item to fetch the version for.     session (requests.Session): The requests session to use for fetching.</p> <p>Raises:     ValueError: If the item is not found, URL returns an error, or no versions are available.</p> <p>Returns:     str: The version of the item.</p> <p>Notes:     - Picks the latest version by string comparison of 'latest_version' if present, otherwise falls back to max of 'versions'.</p> <p>Examples:     &gt;&gt;&gt; provider = BiocondaProvider()     &gt;&gt;&gt; version = provider.fetch_version(\"package_name\", requests.Session())     \"1.0.0\"</p> Source code in <code>src/glasscandle/providers/bioconda.py</code> <pre><code>@dataclass\nclass BiocondaProvider(CondaProvider):\n    \"\"\"\n    Bioconda provider for checking conda package versions.\n\n    This is a specialized version of CondaProvider that only searches the bioconda channel\n    and maintains backward compatibility with the original bioconda provider.\n\n    Attributes:\n      name (str): The name of the provider. Default is \"bioconda\".\n      on_change (Optional[Callable[[str, str, str], None]]): Optional callback function to be called on change.\n\n    Methods:\n      key(item: str) -&gt; str:\n        Returns the key for the given item.\n\n        Args:\n          item (str): The item to generate the key for.\n\n        Returns:\n          str: The key for the item.\n\n      fetch_version(item: str, session: requests.Session) -&gt; str:\n        Fetches the version of the given item from bioconda.\n\n        Args:\n          item (str): The item to fetch the version for.\n          session (requests.Session): The requests session to use for fetching.\n\n        Raises:\n          ValueError: If the item is not found, URL returns an error, or no versions are available.\n\n        Returns:\n          str: The version of the item.\n\n        Notes:\n          - Picks the latest version by string comparison of 'latest_version' if present, otherwise falls back to max of 'versions'.\n\n        Examples:\n          &gt;&gt;&gt; provider = BiocondaProvider()\n          &gt;&gt;&gt; version = provider.fetch_version(\"package_name\", requests.Session())\n          \"1.0.0\"\n    \"\"\"\n    name: str = \"bioconda\"\n    version_constraint: Optional[str] = None\n    on_change: Optional[Callable[[str, str, str], None]] = None\n\n    def __post_init__(self):\n        # Override parent's __post_init__ to set channels to bioconda only\n        self.channels = [\"bioconda\"]\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"Generate database key maintaining backward compatibility.\"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"{self.name}::{package_name}\"\n\n    def url_for(self, item: str, channel: str = \"bioconda\") -&gt; str:\n        \"\"\"\n        Generate API URL for package in specific channel.\n\n        Args:\n            item: Package name\n            channel: Conda channel name\n\n        Returns:\n            API URL for the package in the channel\n        \"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.bioconda.BiocondaProvider.key","title":"<code>key(item)</code>","text":"<p>Generate database key maintaining backward compatibility.</p> Source code in <code>src/glasscandle/providers/bioconda.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"Generate database key maintaining backward compatibility.\"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"{self.name}::{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.bioconda.BiocondaProvider.url_for","title":"<code>url_for(item, channel='bioconda')</code>","text":"<p>Generate API URL for package in specific channel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Package name</p> required <code>channel</code> <code>str</code> <p>Conda channel name</p> <code>'bioconda'</code> <p>Returns:</p> Type Description <code>str</code> <p>API URL for the package in the channel</p> Source code in <code>src/glasscandle/providers/bioconda.py</code> <pre><code>def url_for(self, item: str, channel: str = \"bioconda\") -&gt; str:\n    \"\"\"\n    Generate API URL for package in specific channel.\n\n    Args:\n        item: Package name\n        channel: Conda channel name\n\n    Returns:\n        API URL for the package in the channel\n    \"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.condaforge.CondaForgeProvider","title":"<code>CondaForgeProvider</code>  <code>dataclass</code>","text":"<p>             Bases: <code>CondaProvider</code></p> <p>Conda-forge provider for checking conda package versions.</p> <p>This is a specialized version of CondaProvider that only searches the conda-forge channel and provides a convenient interface for conda-forge packages.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the provider. Default is \"condaforge\".</p> <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Optional callback function to be called on change.</p> Methods <p>key(item: str) -&gt; str:   Returns the key for the given item.</p> <p>Args:     item (str): The item to generate the key for.</p> <p>Returns:     str: The key for the item.</p> <p>fetch_version(item: str, session: requests.Session) -&gt; str:   Fetches the version of the given item from conda-forge.</p> <p>Args:     item (str): The item to fetch the version for.     session (requests.Session): The requests session to use for fetching.</p> <p>Raises:     ValueError: If the item is not found, URL returns an error, or no versions are available.</p> <p>Returns:     str: The version of the item.</p> <p>Notes:     - Picks the latest version by string comparison of 'latest_version' if present, otherwise falls back to max of 'versions'.</p> <p>Examples:     &gt;&gt;&gt; provider = CondaForgeProvider()     &gt;&gt;&gt; version = provider.fetch_version(\"package_name\", requests.Session())     \"1.0.0\"</p> Source code in <code>src/glasscandle/providers/condaforge.py</code> <pre><code>@dataclass\nclass CondaForgeProvider(CondaProvider):\n    \"\"\"\n    Conda-forge provider for checking conda package versions.\n\n    This is a specialized version of CondaProvider that only searches the conda-forge channel\n    and provides a convenient interface for conda-forge packages.\n\n    Attributes:\n      name (str): The name of the provider. Default is \"condaforge\".\n      on_change (Optional[Callable[[str, str, str], None]]): Optional callback function to be called on change.\n\n    Methods:\n      key(item: str) -&gt; str:\n        Returns the key for the given item.\n\n        Args:\n          item (str): The item to generate the key for.\n\n        Returns:\n          str: The key for the item.\n\n      fetch_version(item: str, session: requests.Session) -&gt; str:\n        Fetches the version of the given item from conda-forge.\n\n        Args:\n          item (str): The item to fetch the version for.\n          session (requests.Session): The requests session to use for fetching.\n\n        Raises:\n          ValueError: If the item is not found, URL returns an error, or no versions are available.\n\n        Returns:\n          str: The version of the item.\n\n        Notes:\n          - Picks the latest version by string comparison of 'latest_version' if present, otherwise falls back to max of 'versions'.\n\n        Examples:\n          &gt;&gt;&gt; provider = CondaForgeProvider()\n          &gt;&gt;&gt; version = provider.fetch_version(\"package_name\", requests.Session())\n          \"1.0.0\"\n    \"\"\"\n\n    name: str = \"condaforge\"\n    version_constraint: Optional[str] = None\n    on_change: Optional[Callable[[str, str, str], None]] = None\n\n    def __post_init__(self):\n        # Override parent's __post_init__ to set channels to conda-forge only\n        self.channels = [\"conda-forge\"]\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"Generate database key maintaining backward compatibility.\"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"{self.name}::{package_name}\"\n\n    def url_for(self, item: str, channel: str = \"conda-forge\") -&gt; str:\n        \"\"\"\n        Generate API URL for package in specific channel.\n\n        Args:\n            item: Package name\n            channel: Conda channel name\n\n        Returns:\n            API URL for the package in the channel\n        \"\"\"\n        package_name, _ = self.parse_package_spec(item)\n        return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.condaforge.CondaForgeProvider.key","title":"<code>key(item)</code>","text":"<p>Generate database key maintaining backward compatibility.</p> Source code in <code>src/glasscandle/providers/condaforge.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"Generate database key maintaining backward compatibility.\"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"{self.name}::{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.condaforge.CondaForgeProvider.url_for","title":"<code>url_for(item, channel='conda-forge')</code>","text":"<p>Generate API URL for package in specific channel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Package name</p> required <code>channel</code> <code>str</code> <p>Conda channel name</p> <code>'conda-forge'</code> <p>Returns:</p> Type Description <code>str</code> <p>API URL for the package in the channel</p> Source code in <code>src/glasscandle/providers/condaforge.py</code> <pre><code>def url_for(self, item: str, channel: str = \"conda-forge\") -&gt; str:\n    \"\"\"\n    Generate API URL for package in specific channel.\n\n    Args:\n        item: Package name\n        channel: Conda channel name\n\n    Returns:\n        API URL for the package in the channel\n    \"\"\"\n    package_name, _ = self.parse_package_spec(item)\n    return f\"https://api.anaconda.org/package/{channel}/{package_name}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.url.URLProvider","title":"<code>URLProvider</code>  <code>dataclass</code>","text":"<p>URL provider for checking arbitrary URLs with custom parsers.</p> <p>Attributes:</p> Name Type Description <code>parse</code> <code>Optional[Callable[[requests.Response], str]]</code> <p>Custom parser function for response.</p> <code>name</code> <code>str</code> <p>Name of the URL provider.</p> <code>allow_http</code> <code>bool</code> <p>Flag to allow HTTP URLs.</p> <code>allowed_domains</code> <code>Tuple[str, ...]</code> <p>Tuple of allowed domain names.</p> <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Callback function for URL changes.</p> Source code in <code>src/glasscandle/providers/url.py</code> <pre><code>@dataclass\nclass URLProvider:\n    \"\"\"\n    URL provider for checking arbitrary URLs with custom parsers.\n\n    Attributes:\n      parse (Optional[Callable[[requests.Response], str]]): Custom parser function for response.\n      name (str): Name of the URL provider.\n      allow_http (bool): Flag to allow HTTP URLs.\n      allowed_domains (Tuple[str, ...]): Tuple of allowed domain names.\n      on_change (Optional[Callable[[str, str, str], None]]): Callback function for URL changes.\n    \"\"\"\n    parse: Optional[Callable[[requests.Response], str]] = None\n    name: str = \"url\"\n    allow_http: bool = False\n    allowed_domains: Tuple[str, ...] = ()\n    on_change: Optional[Callable[[str, str, str], None]] = None\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"\n        Generates a unique key for the given URL.\n\n        Args:\n          item (str): The URL for which key is generated.\n\n        Returns:\n          str: Unique key for the URL.\n        \"\"\"\n        # item is the URL\n        return f\"{self.name}::{item}\"\n\n    def url_for(self, item: str) -&gt; str:\n        \"\"\"\n        Returns the URL as is.\n\n        Args:\n          item (str): The URL.\n\n        Returns:\n          str: The input URL.\n        \"\"\"\n        return item\n\n    def _validate(self, url: str) -&gt; None:\n        \"\"\"\n        Validates the URL based on scheme, HTTP allowance, and allowed domains.\n\n        Args:\n          url (str): The URL to validate.\n\n        Raises:\n          ValueError: If URL scheme is unsupported, plain HTTP is blocked, or domain is not allowed.\n        \"\"\"\n        pu = urlparse(url)\n        if pu.scheme not in (\"https\", \"http\"):\n            raise ValueError(\"Unsupported URL scheme\")\n        if pu.scheme == \"http\" and not self.allow_http:\n            raise ValueError(\"Plain HTTP blocked\")\n        host = pu.hostname or \"\"\n        if self.allowed_domains and host not in self.allowed_domains:\n            raise ValueError(f\"Domain not allowed: {host}\")\n\n    def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n        \"\"\"\n        Fetches the version of the given URL using a session.\n\n        Args:\n          item (str): The URL to fetch version for.\n          session (requests.Session): Session object for making HTTP requests.\n\n        Returns:\n          str: Version of the URL content.\n\n        Raises:\n          ValueError: If HTTP request fails, response is too large, parser returns empty string, or other validation issues.\n        \"\"\"\n        from ..http import HTTP_TIMEOUT\n\n        self._validate(item)\n\n        # HEAD probe to avoid huge downloads\n        try:\n            h = session.head(item, timeout=HTTP_TIMEOUT, allow_redirects=True)\n            if h.status_code &gt;= 400 and h.status_code != 405:\n                raise ValueError(f\"{item} HEAD returned {h.status_code}\")\n            clen = h.headers.get(\"Content-Length\")\n            if clen and int(clen) &gt; MAX_BYTES:\n                raise ValueError(f\"Response too large: {clen} bytes\")\n        except requests.RequestException:\n            # fall back to GET if HEAD is not supported or fails\n            pass\n\n        r = session.get(item, timeout=HTTP_TIMEOUT, stream=False)\n        if r.status_code != 200:\n            raise ValueError(f\"{item} returned {r.status_code}\")\n        # Optional: enforce size cap even without Content-Length\n        if r.headers.get(\"Content-Length\") is None and len(r.content) &gt; MAX_BYTES:\n            raise ValueError(\"Response too large without Content-Length\")\n        if self.parse is None:\n            result = r.text.strip()\n        else:\n            result = self.parse(r).strip()\n        if not result:\n            raise ValueError(\"Parser returned empty string\")\n        return result\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.url.URLProvider.fetch_version","title":"<code>fetch_version(item, session)</code>","text":"<p>Fetches the version of the given URL using a session.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The URL to fetch version for.</p> required <code>session</code> <code>requests.Session</code> <p>Session object for making HTTP requests.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Version of the URL content.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If HTTP request fails, response is too large, parser returns empty string, or other validation issues.</p> Source code in <code>src/glasscandle/providers/url.py</code> <pre><code>def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n    \"\"\"\n    Fetches the version of the given URL using a session.\n\n    Args:\n      item (str): The URL to fetch version for.\n      session (requests.Session): Session object for making HTTP requests.\n\n    Returns:\n      str: Version of the URL content.\n\n    Raises:\n      ValueError: If HTTP request fails, response is too large, parser returns empty string, or other validation issues.\n    \"\"\"\n    from ..http import HTTP_TIMEOUT\n\n    self._validate(item)\n\n    # HEAD probe to avoid huge downloads\n    try:\n        h = session.head(item, timeout=HTTP_TIMEOUT, allow_redirects=True)\n        if h.status_code &gt;= 400 and h.status_code != 405:\n            raise ValueError(f\"{item} HEAD returned {h.status_code}\")\n        clen = h.headers.get(\"Content-Length\")\n        if clen and int(clen) &gt; MAX_BYTES:\n            raise ValueError(f\"Response too large: {clen} bytes\")\n    except requests.RequestException:\n        # fall back to GET if HEAD is not supported or fails\n        pass\n\n    r = session.get(item, timeout=HTTP_TIMEOUT, stream=False)\n    if r.status_code != 200:\n        raise ValueError(f\"{item} returned {r.status_code}\")\n    # Optional: enforce size cap even without Content-Length\n    if r.headers.get(\"Content-Length\") is None and len(r.content) &gt; MAX_BYTES:\n        raise ValueError(\"Response too large without Content-Length\")\n    if self.parse is None:\n        result = r.text.strip()\n    else:\n        result = self.parse(r).strip()\n    if not result:\n        raise ValueError(\"Parser returned empty string\")\n    return result\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.url.URLProvider.key","title":"<code>key(item)</code>","text":"<p>Generates a unique key for the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The URL for which key is generated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key for the URL.</p> Source code in <code>src/glasscandle/providers/url.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"\n    Generates a unique key for the given URL.\n\n    Args:\n      item (str): The URL for which key is generated.\n\n    Returns:\n      str: Unique key for the URL.\n    \"\"\"\n    # item is the URL\n    return f\"{self.name}::{item}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.url.URLProvider.url_for","title":"<code>url_for(item)</code>","text":"<p>Returns the URL as is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The URL.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The input URL.</p> Source code in <code>src/glasscandle/providers/url.py</code> <pre><code>def url_for(self, item: str) -&gt; str:\n    \"\"\"\n    Returns the URL as is.\n\n    Args:\n      item (str): The URL.\n\n    Returns:\n      str: The input URL.\n    \"\"\"\n    return item\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.pypi.PyPIProvider","title":"<code>PyPIProvider</code>  <code>dataclass</code>","text":"<p>PyPI provider for checking Python package versions.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the PyPI provider.</p> <code>version_constraint</code> <code>Optional[str]</code> <p>Version constraint string (e.g., \"&gt;=1.21,&lt;2\").</p> <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Optional callback function for when a version changes.</p> Source code in <code>src/glasscandle/providers/pypi.py</code> <pre><code>@dataclass\nclass PyPIProvider:\n    \"\"\"\n    PyPI provider for checking Python package versions.\n\n    Attributes:\n      name (str): The name of the PyPI provider.\n      version_constraint (Optional[str]): Version constraint string (e.g., \"&gt;=1.21,&lt;2\").\n      on_change (Optional[Callable[[str, str, str], None]]): Optional callback function for when a version changes.\n    \"\"\"\n    name: str = \"pypi\"\n    version_constraint: Optional[str] = None\n    on_change: Optional[Callable[[str, str, str], None]] = None\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"\n        Returns a key for the given item.\n\n        Args:\n          item (str): The item to generate a key for.\n\n        Returns:\n          str: The key generated for the item.\n        \"\"\"\n        return f\"{self.name}::{item}\"\n\n    def url_for(self, item: str) -&gt; str:\n        \"\"\"\n        Returns the URL for the given item on PyPI.\n\n        Args:\n          item (str): The item to get the URL for.\n\n        Returns:\n          str: The URL for the item on PyPI.\n        \"\"\"\n        return f\"https://pypi.org/pypi/{item}/json\"\n\n    def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n        \"\"\"\n        Fetches the version of the given item from PyPI.\n\n        Applies version constraints if specified.\n\n        Args:\n          item (str): The item to fetch the version for.\n          session (requests.Session): The requests session to use for fetching.\n\n        Returns:\n          str: The latest version of the item that matches constraints.\n\n        Raises:\n          ValueError: If the item is not found on PyPI, if the URL returns a non-200 status code,\n                     if no version is found in the PyPI response for the item, or if no version\n                     matches the specified constraints.\n        \"\"\"\n        # Use the official JSON API instead of scraping HTML\n        from ..http import HTTP_TIMEOUT\n        from ..version_constraints import VersionConstraint\n\n        url = self.url_for(item)\n        r = session.get(url, timeout=HTTP_TIMEOUT)\n        if r.status_code == 404:\n            raise ValueError(f\"{item} not found on PyPI\")\n        if r.status_code != 200:\n            raise ValueError(f\"{url} returned {r.status_code}\")\n\n        data = r.json()\n\n        # Apply version constraints if specified\n        if self.version_constraint:\n            try:\n                constraint = VersionConstraint(self.version_constraint)\n                # Get all available versions from releases\n                all_versions = list(data.get(\"releases\", {}).keys())\n                if not all_versions:\n                    raise ValueError(f\"No versions found in PyPI response for {item}\")\n\n                # Find the latest version that matches constraints\n                valid_version = constraint.get_latest_valid(all_versions)\n                if valid_version:\n                    return valid_version\n                else:\n                    raise ValueError(f\"No versions for {item} on PyPI match constraint '{self.version_constraint}'\")\n            except Exception as e:\n                if \"Invalid version constraint\" in str(e):\n                    raise e\n                raise ValueError(f\"Error applying version constraint for {item}: {e}\")\n        else:\n            # No constraints, return latest version\n            version = data.get(\"info\", {}).get(\"version\", \"\")\n            if not version:\n                raise ValueError(f\"No version in PyPI response for {item}\")\n            return version\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.pypi.PyPIProvider.fetch_version","title":"<code>fetch_version(item, session)</code>","text":"<p>Fetches the version of the given item from PyPI.</p> <p>Applies version constraints if specified.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The item to fetch the version for.</p> required <code>session</code> <code>requests.Session</code> <p>The requests session to use for fetching.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The latest version of the item that matches constraints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not found on PyPI, if the URL returns a non-200 status code,          if no version is found in the PyPI response for the item, or if no version          matches the specified constraints.</p> Source code in <code>src/glasscandle/providers/pypi.py</code> <pre><code>def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n    \"\"\"\n    Fetches the version of the given item from PyPI.\n\n    Applies version constraints if specified.\n\n    Args:\n      item (str): The item to fetch the version for.\n      session (requests.Session): The requests session to use for fetching.\n\n    Returns:\n      str: The latest version of the item that matches constraints.\n\n    Raises:\n      ValueError: If the item is not found on PyPI, if the URL returns a non-200 status code,\n                 if no version is found in the PyPI response for the item, or if no version\n                 matches the specified constraints.\n    \"\"\"\n    # Use the official JSON API instead of scraping HTML\n    from ..http import HTTP_TIMEOUT\n    from ..version_constraints import VersionConstraint\n\n    url = self.url_for(item)\n    r = session.get(url, timeout=HTTP_TIMEOUT)\n    if r.status_code == 404:\n        raise ValueError(f\"{item} not found on PyPI\")\n    if r.status_code != 200:\n        raise ValueError(f\"{url} returned {r.status_code}\")\n\n    data = r.json()\n\n    # Apply version constraints if specified\n    if self.version_constraint:\n        try:\n            constraint = VersionConstraint(self.version_constraint)\n            # Get all available versions from releases\n            all_versions = list(data.get(\"releases\", {}).keys())\n            if not all_versions:\n                raise ValueError(f\"No versions found in PyPI response for {item}\")\n\n            # Find the latest version that matches constraints\n            valid_version = constraint.get_latest_valid(all_versions)\n            if valid_version:\n                return valid_version\n            else:\n                raise ValueError(f\"No versions for {item} on PyPI match constraint '{self.version_constraint}'\")\n        except Exception as e:\n            if \"Invalid version constraint\" in str(e):\n                raise e\n            raise ValueError(f\"Error applying version constraint for {item}: {e}\")\n    else:\n        # No constraints, return latest version\n        version = data.get(\"info\", {}).get(\"version\", \"\")\n        if not version:\n            raise ValueError(f\"No version in PyPI response for {item}\")\n        return version\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.pypi.PyPIProvider.key","title":"<code>key(item)</code>","text":"<p>Returns a key for the given item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The item to generate a key for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The key generated for the item.</p> Source code in <code>src/glasscandle/providers/pypi.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"\n    Returns a key for the given item.\n\n    Args:\n      item (str): The item to generate a key for.\n\n    Returns:\n      str: The key generated for the item.\n    \"\"\"\n    return f\"{self.name}::{item}\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.pypi.PyPIProvider.url_for","title":"<code>url_for(item)</code>","text":"<p>Returns the URL for the given item on PyPI.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The item to get the URL for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL for the item on PyPI.</p> Source code in <code>src/glasscandle/providers/pypi.py</code> <pre><code>def url_for(self, item: str) -&gt; str:\n    \"\"\"\n    Returns the URL for the given item on PyPI.\n\n    Args:\n      item (str): The item to get the URL for.\n\n    Returns:\n      str: The URL for the item on PyPI.\n    \"\"\"\n    return f\"https://pypi.org/pypi/{item}/json\"\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.base.Provider","title":"<code>Provider</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol for version checking providers.</p> Source code in <code>src/glasscandle/providers/base.py</code> <pre><code>class Provider(Protocol):\n    \"\"\"Protocol for version checking providers.\"\"\"\n    name: str\n\n    def key(self, item: str) -&gt; str:\n        \"\"\"Return the DB key for this provider + item.\"\"\"\n        ...\n\n    def url_for(self, item: str) -&gt; str:\n        \"\"\"Return the canonical lookup URL for this item.\"\"\"\n        ...\n\n    def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n        \"\"\"Return the current version string, or raise ValueError on not found.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.base.Provider.fetch_version","title":"<code>fetch_version(item, session)</code>","text":"<p>Return the current version string, or raise ValueError on not found.</p> Source code in <code>src/glasscandle/providers/base.py</code> <pre><code>def fetch_version(self, item: str, session: requests.Session) -&gt; str:\n    \"\"\"Return the current version string, or raise ValueError on not found.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.base.Provider.key","title":"<code>key(item)</code>","text":"<p>Return the DB key for this provider + item.</p> Source code in <code>src/glasscandle/providers/base.py</code> <pre><code>def key(self, item: str) -&gt; str:\n    \"\"\"Return the DB key for this provider + item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/providers/#src.glasscandle.providers.base.Provider.url_for","title":"<code>url_for(item)</code>","text":"<p>Return the canonical lookup URL for this item.</p> Source code in <code>src/glasscandle/providers/base.py</code> <pre><code>def url_for(self, item: str) -&gt; str:\n    \"\"\"Return the canonical lookup URL for this item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/version_constraints/","title":"Version Constraints","text":"<p>Version constraint utilities for filtering package versions.</p>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint","title":"<code>VersionConstraint</code>","text":"<p>Parse and evaluate version constraints.</p> <p>Supports constraints like: - \"&gt;=1.21,&lt;2\" (greater than or equal to 1.21, less than 2) - \"~=1.21\" (compatible release, equivalent to \"&gt;=1.21,&lt;1.22\") - \"==1.21.0\" (exact version) - \"&gt;1.20\" (greater than 1.20) - \"!=2.0\" (not equal to 2.0)</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>class VersionConstraint:\n    \"\"\"\n    Parse and evaluate version constraints.\n\n    Supports constraints like:\n    - \"&gt;=1.21,&lt;2\" (greater than or equal to 1.21, less than 2)\n    - \"~=1.21\" (compatible release, equivalent to \"&gt;=1.21,&lt;1.22\")\n    - \"==1.21.0\" (exact version)\n    - \"&gt;1.20\" (greater than 1.20)\n    - \"!=2.0\" (not equal to 2.0)\n    \"\"\"\n\n    def __init__(self, constraint_string: str):\n        \"\"\"\n        Initialize version constraint from string.\n\n        Args:\n            constraint_string: Version constraint string (e.g., \"&gt;=1.21,&lt;2\")\n        \"\"\"\n        self.constraint_string = constraint_string.strip()\n        self.constraints = self._parse_constraints()\n\n    def _parse_constraints(self) -&gt; List[tuple]:\n        \"\"\"Parse constraint string into list of (operator, version) tuples.\"\"\"\n        if not self.constraint_string or self.constraint_string == \"*\":\n            return []\n\n        constraints = []\n        # Split by comma and parse each constraint\n        parts = [part.strip() for part in self.constraint_string.split(',')]\n\n        for part in parts:\n            if not part:\n                continue\n\n            # Match operator and version with improved regex\n            # Prevent operator characters in version part to avoid partial matches\n            match = re.match(r'^(~=|==|!=|&lt;=|&gt;=|&lt;|&gt;)\\s*([^&lt;&gt;=!~\\s].*)$', part)\n            if not match:\n                raise ValueError(f\"Invalid version constraint: {part}\")\n\n            operator, version_str = match.groups()\n            version_str = version_str.strip()\n\n            try:\n                parsed_version = version.parse(version_str)\n                constraints.append((operator, parsed_version))\n            except Exception as e:\n                raise ValueError(f\"Invalid version in constraint '{part}': {e}\")\n\n        return constraints\n\n    def matches(self, version_string: str) -&gt; bool:\n        \"\"\"\n        Check if a version string satisfies all constraints.\n\n        Args:\n            version_string: Version string to check\n\n        Returns:\n            True if version satisfies all constraints, False otherwise\n        \"\"\"\n        if not self.constraints:\n            return True  # No constraints means all versions are valid\n\n        try:\n            ver = version.parse(version_string)\n        except Exception:\n            # If we can't parse the version, assume it doesn't match\n            return False\n\n        for operator, constraint_version in self.constraints:\n            if not self._evaluate_constraint(ver, operator, constraint_version):\n                return False\n\n        return True\n\n    def _evaluate_constraint(self, ver: version.Version, operator: str, constraint_version: version.Version) -&gt; bool:\n        \"\"\"Evaluate a single constraint against a version.\"\"\"\n        if operator == \"==\":\n            return ver == constraint_version\n        elif operator == \"!=\":\n            return ver != constraint_version\n        elif operator == \"&gt;\":\n            return ver &gt; constraint_version\n        elif operator == \"&gt;=\":\n            return ver &gt;= constraint_version\n        elif operator == \"&lt;\":\n            return ver &lt; constraint_version\n        elif operator == \"&lt;=\":\n            return ver &lt;= constraint_version\n        elif operator == \"~=\":\n            # Compatible release: same major.minor, but patch can be higher\n            return (ver &gt;= constraint_version and \n                    ver.release[:2] == constraint_version.release[:2])\n        else:\n            raise ValueError(f\"Unknown operator: {operator}\")\n\n    def filter_versions(self, versions: List[str]) -&gt; List[str]:\n        \"\"\"\n        Filter a list of versions to only those matching constraints.\n\n        Args:\n            versions: List of version strings\n\n        Returns:\n            Filtered list of versions that match constraints\n        \"\"\"\n        return [v for v in versions if self.matches(v)]\n\n    def get_latest_valid(self, versions: List[str]) -&gt; Optional[str]:\n        \"\"\"\n        Get the latest version that satisfies constraints.\n\n        Args:\n            versions: List of version strings\n\n        Returns:\n            Latest valid version or None if no versions match\n        \"\"\"\n        valid_versions = self.filter_versions(versions)\n        if not valid_versions:\n            return None\n\n        # Sort versions and return the latest\n        try:\n            sorted_versions = sorted(valid_versions, key=version.parse, reverse=True)\n            return sorted_versions[0]\n        except Exception:\n            # If sorting fails, fall back to string max\n            return max(valid_versions)\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of constraints.\"\"\"\n        return self.constraint_string\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation of constraints.\"\"\"\n        return f\"VersionConstraint('{self.constraint_string}')\"\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.__init__","title":"<code>__init__(constraint_string)</code>","text":"<p>Initialize version constraint from string.</p> <p>Parameters:</p> Name Type Description Default <code>constraint_string</code> <code>str</code> <p>Version constraint string (e.g., \"&gt;=1.21,&lt;2\")</p> required Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def __init__(self, constraint_string: str):\n    \"\"\"\n    Initialize version constraint from string.\n\n    Args:\n        constraint_string: Version constraint string (e.g., \"&gt;=1.21,&lt;2\")\n    \"\"\"\n    self.constraint_string = constraint_string.strip()\n    self.constraints = self._parse_constraints()\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed representation of constraints.</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation of constraints.\"\"\"\n    return f\"VersionConstraint('{self.constraint_string}')\"\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.__str__","title":"<code>__str__()</code>","text":"<p>String representation of constraints.</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of constraints.\"\"\"\n    return self.constraint_string\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.filter_versions","title":"<code>filter_versions(versions)</code>","text":"<p>Filter a list of versions to only those matching constraints.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>List[str]</code> <p>List of version strings</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Filtered list of versions that match constraints</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def filter_versions(self, versions: List[str]) -&gt; List[str]:\n    \"\"\"\n    Filter a list of versions to only those matching constraints.\n\n    Args:\n        versions: List of version strings\n\n    Returns:\n        Filtered list of versions that match constraints\n    \"\"\"\n    return [v for v in versions if self.matches(v)]\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.get_latest_valid","title":"<code>get_latest_valid(versions)</code>","text":"<p>Get the latest version that satisfies constraints.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>List[str]</code> <p>List of version strings</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Latest valid version or None if no versions match</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def get_latest_valid(self, versions: List[str]) -&gt; Optional[str]:\n    \"\"\"\n    Get the latest version that satisfies constraints.\n\n    Args:\n        versions: List of version strings\n\n    Returns:\n        Latest valid version or None if no versions match\n    \"\"\"\n    valid_versions = self.filter_versions(versions)\n    if not valid_versions:\n        return None\n\n    # Sort versions and return the latest\n    try:\n        sorted_versions = sorted(valid_versions, key=version.parse, reverse=True)\n        return sorted_versions[0]\n    except Exception:\n        # If sorting fails, fall back to string max\n        return max(valid_versions)\n</code></pre>"},{"location":"reference/version_constraints/#src.glasscandle.version_constraints.VersionConstraint.matches","title":"<code>matches(version_string)</code>","text":"<p>Check if a version string satisfies all constraints.</p> <p>Parameters:</p> Name Type Description Default <code>version_string</code> <code>str</code> <p>Version string to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if version satisfies all constraints, False otherwise</p> Source code in <code>src/glasscandle/version_constraints.py</code> <pre><code>def matches(self, version_string: str) -&gt; bool:\n    \"\"\"\n    Check if a version string satisfies all constraints.\n\n    Args:\n        version_string: Version string to check\n\n    Returns:\n        True if version satisfies all constraints, False otherwise\n    \"\"\"\n    if not self.constraints:\n        return True  # No constraints means all versions are valid\n\n    try:\n        ver = version.parse(version_string)\n    except Exception:\n        # If we can't parse the version, assume it doesn't match\n        return False\n\n    for operator, constraint_version in self.constraints:\n        if not self._evaluate_constraint(ver, operator, constraint_version):\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/watcher/","title":"Watcher","text":""},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher","title":"<code>Watcher</code>","text":"<p>Main watcher class for tracking version changes across different providers.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Path</code> <p>Path to the JSON database file</p> required <code>allowed_custom_domains</code> <code>Tuple[str, ...]</code> <p>Tuple of allowed domains for custom URL monitoring</p> <code>()</code> <code>conda_channels</code> <code>Optional[List[str]]</code> <p>Default conda channels to search (default: [\"conda-forge\", \"bioconda\"])</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Default callback function(s) called when version changes occur               and no specific on_change is provided. Can be a single function               or a list of functions. Each receives (key, old_version, new_version).</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>class Watcher:\n    \"\"\"Main watcher class for tracking version changes across different providers.\n\n    Args:\n        db: Path to the JSON database file\n        allowed_custom_domains: Tuple of allowed domains for custom URL monitoring\n        conda_channels: Default conda channels to search (default: [\"conda-forge\", \"bioconda\"])\n        on_change: Default callback function(s) called when version changes occur\n                          and no specific on_change is provided. Can be a single function\n                          or a list of functions. Each receives (key, old_version, new_version).\n    \"\"\"\n\n    def __init__(self, db: Path, allowed_custom_domains: Tuple[str, ...] = (), \n                 conda_channels: Optional[List[str]] = None, \n                 on_change: Optional[NotifierCallback] = None):\n        \"\"\"\n        Main watcher class for tracking version changes across different providers.\n\n        Args:\n          db (Path): Path to the JSON database file\n          allowed_custom_domains (Tuple[str, ...]): Tuple of allowed domains for custom URL monitoring\n          conda_channels (Optional[List[str]]): Default conda channels to search (default: [\"conda-forge\", \"bioconda\"])\n          on_change (Optional[NotifierCallback]): Default callback function(s) called when version changes occur\n                                and no specific on_change is provided. Can be a single function\n                                or a list of functions. Each receives (key, old_version, new_version).\n        \"\"\"\n        self.db = DB(db)\n        self.pool = Pool()\n        self._session = create_session()\n        self._allowed_custom_domains = allowed_custom_domains\n        self._conda_channels = conda_channels or [\"conda-forge\", \"bioconda\"]\n        self._on_change = on_change\n\n    # Registration methods\n    def conda(self, name: str, *, channels: Optional[List[str]] = None, \n             version: Optional[str] = None,\n             on_change: Optional[NotifierCallback] = None) -&gt; None:\n        \"\"\"Register a conda package for monitoring across multiple channels.\n\n        Args:\n            name: Package name to monitor. Can include channel prefix (e.g., \"bioconda::samtools\")\n            channels: Optional list of channels to search. If None, uses default channels.\n                     Ignored if name includes channel prefix.\n            version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                    Only versions matching this constraint will trigger updates.\n            on_change: Optional callback function(s) called when version changes.\n                      Can be a single function or list of functions.\n                      Each receives (key, old_version, new_version) as arguments.\n\n        Examples:\n            # Search default channels (conda-forge, bioconda)\n            watcher.conda(\"samtools\")\n\n            # Search specific channels only\n            watcher.conda(\"samtools\", channels=[\"bioconda\"])\n\n            # Use channel prefix (ignores channels parameter)\n            watcher.conda(\"bioconda::samtools\")\n\n            # Only update for versions &gt;= 1.21 but &lt; 2.0\n            watcher.conda(\"numpy\", version=\"&gt;=1.21,&lt;2\")\n\n            # Compatible release constraint (1.21.x series only)\n            watcher.conda(\"scipy\", version=\"~=1.21\")\n        \"\"\"\n        # Use provided channels, or fall back to instance default, or global default\n        if channels is None:\n            channels = self._conda_channels\n\n        provider = CondaProvider(channels=channels, version_constraint=version)\n        provider.on_change = on_change\n        self.pool.conda[name] = provider\n\n    def bioconda(self, name: str, *, version: Optional[str] = None,\n                 on_change: Optional[NotifierCallback] = None) -&gt; None:\n        \"\"\"Register a bioconda package for monitoring.\n\n        Args:\n            name: Package name to monitor\n            version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                    Only versions matching this constraint will trigger updates.\n            on_change: Optional callback function(s) called when version changes.\n                      Can be a single function or list of functions.\n                      Each receives (key, old_version, new_version) as arguments.\n\n        Examples:\n            # Monitor any version updates\n            watcher.bioconda(\"samtools\")\n\n            # Only update for versions &gt;= 1.15 but &lt; 2.0\n            watcher.bioconda(\"samtools\", version=\"&gt;=1.15,&lt;2\")\n        \"\"\"\n        provider = BiocondaProvider(version_constraint=version)\n        provider.on_change = on_change\n        self.pool.bioconda[name] = provider\n\n    def pypi(self, name: str, *, version: Optional[str] = None, \n             on_change: Optional[NotifierCallback] = None) -&gt; None:\n        \"\"\"Register a PyPI package for monitoring.\n\n        Args:\n            name: Package name to monitor\n            version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                    Only versions matching this constraint will trigger updates.\n            on_change: Optional callback function(s) called when version changes.\n                      Can be a single function or list of functions.\n                      Each receives (key, old_version, new_version) as arguments.\n\n        Examples:\n            # Monitor any version updates\n            watcher.pypi(\"requests\")\n\n            # Only update for versions &gt;= 2.25 but &lt; 3.0\n            watcher.pypi(\"requests\", version=\"&gt;=2.25,&lt;3\")\n\n            # Compatible release constraint (2.25.x series only)\n            watcher.pypi(\"requests\", version=\"~=2.25\")\n        \"\"\"\n        provider = PyPIProvider(version_constraint=version)\n        provider.on_change = on_change\n        self.pool.pypi[name] = provider\n\n    def url(self, url: str,\n            parser: Callable[[requests.Response], str] = None,\n            *,\n            allow_http: bool = False,\n            allowed_domains: Optional[Tuple[str, ...]] = None,\n            on_change: Optional[NotifierCallback] = None) -&gt; None:\n        \"\"\"Register a general URL with a parser function.\n\n        Args:\n            url: URL to monitor\n            parser: Function to parse the response and extract version\n            allow_http: Whether to allow plain HTTP URLs\n            allowed_domains: Tuple of allowed domains for this URL\n            on_change: Optional callback function called when version changes.\n                      Receives (key, old_version, new_version) as arguments.\n        \"\"\"\n        prov = URLProvider(\n            parse=parser,\n            allow_http=allow_http,\n            allowed_domains=allowed_domains or self._allowed_custom_domains,\n        )\n        prov.on_change = on_change\n        # validate now, fail fast\n        prov._validate(url)\n        self.pool.url[url] = prov\n\n    def url_regex(self, url: str, pattern: str, *, group: int = 1, \n                  on_change: Optional[NotifierCallback] = None, **kwargs) -&gt; None:\n        \"\"\"Register a URL with a regex parser.\n\n        Args:\n            url: URL to monitor\n            pattern: Regex pattern to extract version\n            group: Regex group number to capture (default: 1)\n            on_change: Optional callback function called when version changes.\n                      Receives (key, old_version, new_version) as arguments.\n        \"\"\"\n        self.url(url, parser=regex(pattern, group), on_change=on_change, **kwargs)\n\n    def response(self, url: str, on_change: Optional[Callable[[str, str, str], None]] = None) -&gt; Callable[[CustomFunc], CustomFunc]:\n        \"\"\"Decorator for custom Response parsers.\n\n        Args:\n            url: URL to monitor\n            on_change: Optional callback function called when version changes.\n                      Receives (key, old_version, new_version) as arguments.\n        \"\"\"\n        host = (urlparse(url).hostname or \"\")\n        if self._allowed_custom_domains and host not in self._allowed_custom_domains:\n            raise ValueError(f\"Custom URL domain not allowed: {host}\")\n\n        def decorator(func: CustomFunc) -&gt; CustomFunc:\n            \"\"\"\n        This method is not defined in the provided code.\n        \"\"\"\n            self.pool.custom[url] = func\n            self.pool.custom_callbacks[url] = on_change\n            return func\n        return decorator\n\n    def json(self, url: str, path: str, \n             on_change: Optional[NotifierCallback] = None, **kwargs) -&gt; None:\n        \"\"\"Register a URL with a JSONPath parser.\n\n        Args:\n            url: URL to monitor (should return JSON)\n            path: JSONPath expression to extract version (e.g., \"$.version\", \"$.data[0].tag_name\")\n            on_change: Optional callback function called when version changes.\n                      Receives (key, old_version, new_version) as arguments.\n        \"\"\"\n        self.url(url, parser=jsonpath(path), on_change=on_change, **kwargs)\n\n    # Core functionality\n    def _update(self, key: str, new_value: str, on_change: Optional[NotifierCallback] = None) -&gt; bool:\n        \"\"\"Update a value in the database if it has changed.\"\"\"\n        old_value = self.db.get(key)\n        if old_value == new_value:\n            print(f\"Skipping {key} as it is up to date.\")\n            return False  # No update needed\n        print(f\"Updating {key}: {old_value} -&gt; {new_value}\")\n        self.db.put(key, new_value)\n\n        # Use provided callback, or fall back to default\n        callback = on_change or self._on_change\n\n        # Call the callback if available\n        if callback:\n            try:\n                _call_notifiers(callback, key, old_value or \"\", new_value)\n            except Exception as e:\n                print(f\"[WARN] on_change callback for {key} failed: {e}\")\n        return True  # Update was successful\n\n    def run(self, warn=False) -&gt; bool:\n        \"\"\"Run a single check of all registered providers.\"\"\"\n        providers: Tuple[Tuple[Dict[str, Provider], Provider], ...] = (\n            (self._wrap(self.pool.bioconda), BiocondaProvider()),\n            (self._wrap(self.pool.conda), CondaProvider()),\n            (self._wrap(self.pool.condaforge), CondaForgeProvider()),\n            (self._wrap(self.pool.pypi), PyPIProvider()),\n            (self._wrap(self.pool.url), URLProvider()),  # proto only for .name\n        )\n\n        updated = False\n        for items_map, proto in providers:\n            for item, provider in items_map.items():\n                try:\n                    version = provider.fetch_version(item, self._session)\n                    on_change = getattr(provider, 'on_change', None)\n                    if self._update(provider.key(item), version, on_change):\n                        updated = True\n                except (requests.RequestException, ValueError, json.JSONDecodeError) as e:\n                    if warn:\n                        print(f\"[WARN] {proto.name}:{item} failed: {e}\")\n                    else:\n                        raise ValueError(f\"Failed to fetch {proto.name} version for {item}: {e}\")\n\n        # Custom callables keep raw Response, but we still key them as url::URL\n        for url, func in self.pool.custom.items():\n            try:\n                res = self._session.get(url, timeout=HTTP_TIMEOUT)\n                if res.status_code != 200:\n                    raise ValueError(f\"{url} returned {res.status_code}\")\n                result = func(res)\n                on_change = self.pool.custom_callbacks.get(url)\n                if self._update(f\"url::{url}\", result, on_change):\n                    updated = True\n            except (requests.RequestException, ValueError) as e:\n                if warn:\n                    print(f\"[WARN] custom:{url} failed: {e}\")\n                else:\n                    raise ValueError(f\"Failed to fetch custom URL {url}: {e}\")\n        return updated\n\n    def start(self, interval: int = 60) -&gt; None:\n        \"\"\"Start continuous monitoring with the specified interval.\"\"\"\n        try:\n            while True:\n                self.run()\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"Stopped.\")\n\n    @staticmethod\n    def _wrap(d: Dict[str, Provider]) -&gt; Dict[str, Provider]:\n        \"\"\"Wrapper for provider instances (no-op in current implementation).\"\"\"\n        # If callers added raw names, convert to provider instances\n        # In our registrations we already store instances, so this is no-op.\n        return d\n\n    def condaforge(self, name: str, *, version: Optional[str] = None,\n                   on_change: Optional[NotifierCallback] = None) -&gt; None:\n        \"\"\"Register a conda-forge package for monitoring.\n\n        Args:\n            name: Package name to monitor\n            version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                    Only versions matching this constraint will trigger updates.\n            on_change: Optional callback function(s) called when version changes.\n                      Can be a single function or list of functions.\n                      Each receives (key, old_version, new_version) as arguments.\n\n        Examples:\n            # Monitor any version updates\n            watcher.condaforge(\"numpy\")\n\n            # Only update for versions &gt;= 1.21 but &lt; 2.0\n            watcher.condaforge(\"numpy\", version=\"&gt;=1.21,&lt;2\")\n        \"\"\"\n        provider = CondaForgeProvider(version_constraint=version)\n        provider.on_change = on_change\n        self.pool.condaforge[name] = provider\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.__init__","title":"<code>__init__(db, allowed_custom_domains=(), conda_channels=None, on_change=None)</code>","text":"<p>Main watcher class for tracking version changes across different providers.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Path</code> <p>Path to the JSON database file</p> required <code>allowed_custom_domains</code> <code>Tuple[str, ...]</code> <p>Tuple of allowed domains for custom URL monitoring</p> <code>()</code> <code>conda_channels</code> <code>Optional[List[str]]</code> <p>Default conda channels to search (default: [\"conda-forge\", \"bioconda\"])</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Default callback function(s) called when version changes occur                     and no specific on_change is provided. Can be a single function                     or a list of functions. Each receives (key, old_version, new_version).</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def __init__(self, db: Path, allowed_custom_domains: Tuple[str, ...] = (), \n             conda_channels: Optional[List[str]] = None, \n             on_change: Optional[NotifierCallback] = None):\n    \"\"\"\n    Main watcher class for tracking version changes across different providers.\n\n    Args:\n      db (Path): Path to the JSON database file\n      allowed_custom_domains (Tuple[str, ...]): Tuple of allowed domains for custom URL monitoring\n      conda_channels (Optional[List[str]]): Default conda channels to search (default: [\"conda-forge\", \"bioconda\"])\n      on_change (Optional[NotifierCallback]): Default callback function(s) called when version changes occur\n                            and no specific on_change is provided. Can be a single function\n                            or a list of functions. Each receives (key, old_version, new_version).\n    \"\"\"\n    self.db = DB(db)\n    self.pool = Pool()\n    self._session = create_session()\n    self._allowed_custom_domains = allowed_custom_domains\n    self._conda_channels = conda_channels or [\"conda-forge\", \"bioconda\"]\n    self._on_change = on_change\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.bioconda","title":"<code>bioconda(name, *, version=None, on_change=None)</code>","text":"<p>Register a bioconda package for monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to monitor</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\").      Only versions matching this constraint will trigger updates.</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function(s) called when version changes.       Can be a single function or list of functions.       Each receives (key, old_version, new_version) as arguments.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.bioconda--monitor-any-version-updates","title":"Monitor any version updates","text":"<p>watcher.bioconda(\"samtools\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.bioconda--only-update-for-versions-115-but-20","title":"Only update for versions &gt;= 1.15 but &lt; 2.0","text":"<p>watcher.bioconda(\"samtools\", version=\"&gt;=1.15,&lt;2\")</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def bioconda(self, name: str, *, version: Optional[str] = None,\n             on_change: Optional[NotifierCallback] = None) -&gt; None:\n    \"\"\"Register a bioconda package for monitoring.\n\n    Args:\n        name: Package name to monitor\n        version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                Only versions matching this constraint will trigger updates.\n        on_change: Optional callback function(s) called when version changes.\n                  Can be a single function or list of functions.\n                  Each receives (key, old_version, new_version) as arguments.\n\n    Examples:\n        # Monitor any version updates\n        watcher.bioconda(\"samtools\")\n\n        # Only update for versions &gt;= 1.15 but &lt; 2.0\n        watcher.bioconda(\"samtools\", version=\"&gt;=1.15,&lt;2\")\n    \"\"\"\n    provider = BiocondaProvider(version_constraint=version)\n    provider.on_change = on_change\n    self.pool.bioconda[name] = provider\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda","title":"<code>conda(name, *, channels=None, version=None, on_change=None)</code>","text":"<p>Register a conda package for monitoring across multiple channels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to monitor. Can include channel prefix (e.g., \"bioconda::samtools\")</p> required <code>channels</code> <code>Optional[List[str]]</code> <p>Optional list of channels to search. If None, uses default channels.      Ignored if name includes channel prefix.</p> <code>None</code> <code>version</code> <code>Optional[str]</code> <p>Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\").      Only versions matching this constraint will trigger updates.</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function(s) called when version changes.       Can be a single function or list of functions.       Each receives (key, old_version, new_version) as arguments.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda--search-default-channels-conda-forge-bioconda","title":"Search default channels (conda-forge, bioconda)","text":"<p>watcher.conda(\"samtools\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda--search-specific-channels-only","title":"Search specific channels only","text":"<p>watcher.conda(\"samtools\", channels=[\"bioconda\"])</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda--use-channel-prefix-ignores-channels-parameter","title":"Use channel prefix (ignores channels parameter)","text":"<p>watcher.conda(\"bioconda::samtools\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda--only-update-for-versions-121-but-20","title":"Only update for versions &gt;= 1.21 but &lt; 2.0","text":"<p>watcher.conda(\"numpy\", version=\"&gt;=1.21,&lt;2\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.conda--compatible-release-constraint-121x-series-only","title":"Compatible release constraint (1.21.x series only)","text":"<p>watcher.conda(\"scipy\", version=\"~=1.21\")</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def conda(self, name: str, *, channels: Optional[List[str]] = None, \n         version: Optional[str] = None,\n         on_change: Optional[NotifierCallback] = None) -&gt; None:\n    \"\"\"Register a conda package for monitoring across multiple channels.\n\n    Args:\n        name: Package name to monitor. Can include channel prefix (e.g., \"bioconda::samtools\")\n        channels: Optional list of channels to search. If None, uses default channels.\n                 Ignored if name includes channel prefix.\n        version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                Only versions matching this constraint will trigger updates.\n        on_change: Optional callback function(s) called when version changes.\n                  Can be a single function or list of functions.\n                  Each receives (key, old_version, new_version) as arguments.\n\n    Examples:\n        # Search default channels (conda-forge, bioconda)\n        watcher.conda(\"samtools\")\n\n        # Search specific channels only\n        watcher.conda(\"samtools\", channels=[\"bioconda\"])\n\n        # Use channel prefix (ignores channels parameter)\n        watcher.conda(\"bioconda::samtools\")\n\n        # Only update for versions &gt;= 1.21 but &lt; 2.0\n        watcher.conda(\"numpy\", version=\"&gt;=1.21,&lt;2\")\n\n        # Compatible release constraint (1.21.x series only)\n        watcher.conda(\"scipy\", version=\"~=1.21\")\n    \"\"\"\n    # Use provided channels, or fall back to instance default, or global default\n    if channels is None:\n        channels = self._conda_channels\n\n    provider = CondaProvider(channels=channels, version_constraint=version)\n    provider.on_change = on_change\n    self.pool.conda[name] = provider\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.condaforge","title":"<code>condaforge(name, *, version=None, on_change=None)</code>","text":"<p>Register a conda-forge package for monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to monitor</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\").      Only versions matching this constraint will trigger updates.</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function(s) called when version changes.       Can be a single function or list of functions.       Each receives (key, old_version, new_version) as arguments.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.condaforge--monitor-any-version-updates","title":"Monitor any version updates","text":"<p>watcher.condaforge(\"numpy\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.condaforge--only-update-for-versions-121-but-20","title":"Only update for versions &gt;= 1.21 but &lt; 2.0","text":"<p>watcher.condaforge(\"numpy\", version=\"&gt;=1.21,&lt;2\")</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def condaforge(self, name: str, *, version: Optional[str] = None,\n               on_change: Optional[NotifierCallback] = None) -&gt; None:\n    \"\"\"Register a conda-forge package for monitoring.\n\n    Args:\n        name: Package name to monitor\n        version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                Only versions matching this constraint will trigger updates.\n        on_change: Optional callback function(s) called when version changes.\n                  Can be a single function or list of functions.\n                  Each receives (key, old_version, new_version) as arguments.\n\n    Examples:\n        # Monitor any version updates\n        watcher.condaforge(\"numpy\")\n\n        # Only update for versions &gt;= 1.21 but &lt; 2.0\n        watcher.condaforge(\"numpy\", version=\"&gt;=1.21,&lt;2\")\n    \"\"\"\n    provider = CondaForgeProvider(version_constraint=version)\n    provider.on_change = on_change\n    self.pool.condaforge[name] = provider\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.json","title":"<code>json(url, path, on_change=None, **kwargs)</code>","text":"<p>Register a URL with a JSONPath parser.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to monitor (should return JSON)</p> required <code>path</code> <code>str</code> <p>JSONPath expression to extract version (e.g., \"$.version\", \"$.data[0].tag_name\")</p> required <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function called when version changes.       Receives (key, old_version, new_version) as arguments.</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def json(self, url: str, path: str, \n         on_change: Optional[NotifierCallback] = None, **kwargs) -&gt; None:\n    \"\"\"Register a URL with a JSONPath parser.\n\n    Args:\n        url: URL to monitor (should return JSON)\n        path: JSONPath expression to extract version (e.g., \"$.version\", \"$.data[0].tag_name\")\n        on_change: Optional callback function called when version changes.\n                  Receives (key, old_version, new_version) as arguments.\n    \"\"\"\n    self.url(url, parser=jsonpath(path), on_change=on_change, **kwargs)\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.pypi","title":"<code>pypi(name, *, version=None, on_change=None)</code>","text":"<p>Register a PyPI package for monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to monitor</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\").      Only versions matching this constraint will trigger updates.</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function(s) called when version changes.       Can be a single function or list of functions.       Each receives (key, old_version, new_version) as arguments.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.pypi--monitor-any-version-updates","title":"Monitor any version updates","text":"<p>watcher.pypi(\"requests\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.pypi--only-update-for-versions-225-but-30","title":"Only update for versions &gt;= 2.25 but &lt; 3.0","text":"<p>watcher.pypi(\"requests\", version=\"&gt;=2.25,&lt;3\")</p>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.pypi--compatible-release-constraint-225x-series-only","title":"Compatible release constraint (2.25.x series only)","text":"<p>watcher.pypi(\"requests\", version=\"~=2.25\")</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def pypi(self, name: str, *, version: Optional[str] = None, \n         on_change: Optional[NotifierCallback] = None) -&gt; None:\n    \"\"\"Register a PyPI package for monitoring.\n\n    Args:\n        name: Package name to monitor\n        version: Optional version constraint (e.g., \"&gt;=1.21,&lt;2\", \"~=1.21\"). \n                Only versions matching this constraint will trigger updates.\n        on_change: Optional callback function(s) called when version changes.\n                  Can be a single function or list of functions.\n                  Each receives (key, old_version, new_version) as arguments.\n\n    Examples:\n        # Monitor any version updates\n        watcher.pypi(\"requests\")\n\n        # Only update for versions &gt;= 2.25 but &lt; 3.0\n        watcher.pypi(\"requests\", version=\"&gt;=2.25,&lt;3\")\n\n        # Compatible release constraint (2.25.x series only)\n        watcher.pypi(\"requests\", version=\"~=2.25\")\n    \"\"\"\n    provider = PyPIProvider(version_constraint=version)\n    provider.on_change = on_change\n    self.pool.pypi[name] = provider\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.response","title":"<code>response(url, on_change=None)</code>","text":"<p>Decorator for custom Response parsers.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to monitor</p> required <code>on_change</code> <code>Optional[Callable[[str, str, str], None]]</code> <p>Optional callback function called when version changes.       Receives (key, old_version, new_version) as arguments.</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def response(self, url: str, on_change: Optional[Callable[[str, str, str], None]] = None) -&gt; Callable[[CustomFunc], CustomFunc]:\n    \"\"\"Decorator for custom Response parsers.\n\n    Args:\n        url: URL to monitor\n        on_change: Optional callback function called when version changes.\n                  Receives (key, old_version, new_version) as arguments.\n    \"\"\"\n    host = (urlparse(url).hostname or \"\")\n    if self._allowed_custom_domains and host not in self._allowed_custom_domains:\n        raise ValueError(f\"Custom URL domain not allowed: {host}\")\n\n    def decorator(func: CustomFunc) -&gt; CustomFunc:\n        \"\"\"\n    This method is not defined in the provided code.\n    \"\"\"\n        self.pool.custom[url] = func\n        self.pool.custom_callbacks[url] = on_change\n        return func\n    return decorator\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.run","title":"<code>run(warn=False)</code>","text":"<p>Run a single check of all registered providers.</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def run(self, warn=False) -&gt; bool:\n    \"\"\"Run a single check of all registered providers.\"\"\"\n    providers: Tuple[Tuple[Dict[str, Provider], Provider], ...] = (\n        (self._wrap(self.pool.bioconda), BiocondaProvider()),\n        (self._wrap(self.pool.conda), CondaProvider()),\n        (self._wrap(self.pool.condaforge), CondaForgeProvider()),\n        (self._wrap(self.pool.pypi), PyPIProvider()),\n        (self._wrap(self.pool.url), URLProvider()),  # proto only for .name\n    )\n\n    updated = False\n    for items_map, proto in providers:\n        for item, provider in items_map.items():\n            try:\n                version = provider.fetch_version(item, self._session)\n                on_change = getattr(provider, 'on_change', None)\n                if self._update(provider.key(item), version, on_change):\n                    updated = True\n            except (requests.RequestException, ValueError, json.JSONDecodeError) as e:\n                if warn:\n                    print(f\"[WARN] {proto.name}:{item} failed: {e}\")\n                else:\n                    raise ValueError(f\"Failed to fetch {proto.name} version for {item}: {e}\")\n\n    # Custom callables keep raw Response, but we still key them as url::URL\n    for url, func in self.pool.custom.items():\n        try:\n            res = self._session.get(url, timeout=HTTP_TIMEOUT)\n            if res.status_code != 200:\n                raise ValueError(f\"{url} returned {res.status_code}\")\n            result = func(res)\n            on_change = self.pool.custom_callbacks.get(url)\n            if self._update(f\"url::{url}\", result, on_change):\n                updated = True\n        except (requests.RequestException, ValueError) as e:\n            if warn:\n                print(f\"[WARN] custom:{url} failed: {e}\")\n            else:\n                raise ValueError(f\"Failed to fetch custom URL {url}: {e}\")\n    return updated\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.start","title":"<code>start(interval=60)</code>","text":"<p>Start continuous monitoring with the specified interval.</p> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def start(self, interval: int = 60) -&gt; None:\n    \"\"\"Start continuous monitoring with the specified interval.\"\"\"\n    try:\n        while True:\n            self.run()\n            time.sleep(interval)\n    except KeyboardInterrupt:\n        print(\"Stopped.\")\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.url","title":"<code>url(url, parser=None, *, allow_http=False, allowed_domains=None, on_change=None)</code>","text":"<p>Register a general URL with a parser function.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to monitor</p> required <code>parser</code> <code>Callable[[requests.Response], str]</code> <p>Function to parse the response and extract version</p> <code>None</code> <code>allow_http</code> <code>bool</code> <p>Whether to allow plain HTTP URLs</p> <code>False</code> <code>allowed_domains</code> <code>Optional[Tuple[str, ...]]</code> <p>Tuple of allowed domains for this URL</p> <code>None</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function called when version changes.       Receives (key, old_version, new_version) as arguments.</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def url(self, url: str,\n        parser: Callable[[requests.Response], str] = None,\n        *,\n        allow_http: bool = False,\n        allowed_domains: Optional[Tuple[str, ...]] = None,\n        on_change: Optional[NotifierCallback] = None) -&gt; None:\n    \"\"\"Register a general URL with a parser function.\n\n    Args:\n        url: URL to monitor\n        parser: Function to parse the response and extract version\n        allow_http: Whether to allow plain HTTP URLs\n        allowed_domains: Tuple of allowed domains for this URL\n        on_change: Optional callback function called when version changes.\n                  Receives (key, old_version, new_version) as arguments.\n    \"\"\"\n    prov = URLProvider(\n        parse=parser,\n        allow_http=allow_http,\n        allowed_domains=allowed_domains or self._allowed_custom_domains,\n    )\n    prov.on_change = on_change\n    # validate now, fail fast\n    prov._validate(url)\n    self.pool.url[url] = prov\n</code></pre>"},{"location":"reference/watcher/#src.glasscandle.watcher.Watcher.url_regex","title":"<code>url_regex(url, pattern, *, group=1, on_change=None, **kwargs)</code>","text":"<p>Register a URL with a regex parser.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to monitor</p> required <code>pattern</code> <code>str</code> <p>Regex pattern to extract version</p> required <code>group</code> <code>int</code> <p>Regex group number to capture (default: 1)</p> <code>1</code> <code>on_change</code> <code>Optional[NotifierCallback]</code> <p>Optional callback function called when version changes.       Receives (key, old_version, new_version) as arguments.</p> <code>None</code> Source code in <code>src/glasscandle/watcher.py</code> <pre><code>def url_regex(self, url: str, pattern: str, *, group: int = 1, \n              on_change: Optional[NotifierCallback] = None, **kwargs) -&gt; None:\n    \"\"\"Register a URL with a regex parser.\n\n    Args:\n        url: URL to monitor\n        pattern: Regex pattern to extract version\n        group: Regex group number to capture (default: 1)\n        on_change: Optional callback function called when version changes.\n                  Receives (key, old_version, new_version) as arguments.\n    \"\"\"\n    self.url(url, parser=regex(pattern, group), on_change=on_change, **kwargs)\n</code></pre>"}]}